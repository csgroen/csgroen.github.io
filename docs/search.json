[
  {
    "objectID": "posts/dockerize_my_analysis/index.html",
    "href": "posts/dockerize_my_analysis/index.html",
    "title": "Dockerizing my R environment for reproducibility",
    "section": "",
    "text": "I love working in R because they make data analysis incredibly convenient. But guarding my analyses against package updates has always been a mixed bag. We’re looking at you, DiffBind.\nI’ve known about docker for a while, but I always considered it the nuclear option for reproducibility: effective, but complicated and possibly a time-destroyer.\nSo I decided to give renv a try. It worked well locally during development, but the problem revealed itself when I tried sharing my analysis with my lab mates to test its “reproducibility status”. It was a complex analysis that loaded many packages and their complex dependency trees. It took forever to get up and running in their computers, and required them to Linux libraries making the whole process more than I’d bargained for.\nSo I thought: “fine, I’ll try docker”. And I think I figured out the magic formula: docker + renv + R scripts = beautiful reproducibility baby."
  },
  {
    "objectID": "posts/dockerize_my_analysis/index.html#docker-renv",
    "href": "posts/dockerize_my_analysis/index.html#docker-renv",
    "title": "Dockerizing my R environment for reproducibility",
    "section": "Docker + renv",
    "text": "Docker + renv\nFor this to work, you’ll need to install docker and renv:\n\ninstall.packages(\"renv\")\n\nOf course, this works better with Rstudio, but should work regardless. We’ll make a simple analysis here so that this post itself is reproducible.\nFirst, I’ll create a new directory for my project. In the example, we’ll call it, creatively, “example”.\n\nMinimal reproducible script example\nFirst, a note:\n\nOf course for a project of the complexity of this example, all you’d need is an .Rmd (or .qmd 😉) knit into an html. But analyses can get quite complex, and everything I wrote here I have tested in a much more complex real life example I used to organize my code for publication.\n\nNow, let’s create a little analysis:\n\ndir.create(\"example\")\n\nWarning in dir.create(\"example\"): 'example' already exists\n\n\nInside this folder, we’ll add all our analysis scripts. In this case, there will be only one: “sleepytime.R”.\nLet’s make a fun animal plot: how long to mammals sleep?\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\ndata(\"msleep\")\nmsleep2 <- msleep %>%\n    select(name, vore, sleep_total) %>%\n    filter(!is.na(vore))\n\n\nsleepiest <- top_n(msleep2, 5, sleep_total) %>% .[c(1,3,5),]\nleast_sleepy <- top_n(msleep2, -3, sleep_total)\nmiddle <- msleep2 %>% filter(name %in% c(\"Dog\", \"Human\", \"Macaque\"))\n\nannots <- bind_rows(sleepiest, least_sleepy, middle)\n\n\nlibrary(ggbeeswarm)\nlibrary(ggrepel)\nggplot(msleep2, aes(vore, fill = vore, sleep_total)) +\n    geom_violin(alpha = 0.5) +\n    geom_quasirandom(size = 1) +\n    geom_text_repel(aes(label = name), size = 3, data = annots, hjust = 0, vjust = 1) +\n    stat_summary(fun = median, geom = \"crossbar\", width = 0.6, size = 0.2) +\n    labs(x = \"Feeding behavior (vore)\", y = \"Total sleep per night (hours)\") +\n    guides(fill = \"none\") +\n    theme_light()\n\n\n\n\nWe’ll add the results of this very complex analysis to a script (sleep.R), and then activate and freeze our environment.\n\nrenv::activate()\n# run script\nrenv::snapshot() # this might take a while\n\nYou’ll then have the file you need, the renv.lock that has all the packages needed. You can download the project files from Github.\n\n\nCreating our docker\nNow we need to create our docker file. There’s a lot more information about it here and a cheat sheet on docker here. But here’s how I think is easiest to do for R reproducible analyses.\nMy R docker philosophy is that we keep code and data separate from our environment. The docker will only contain the environment to reproduce the analysis. The code and data will be mounted into the docker when it is run. This means you can still modify the code once the docker image has been built and don’t need to build it again every time, as long as you didn’t add any new dependencies in the new code. This will greatly simplify our lives, while still ensuring full reproducibility of results.\nThat being said, time to assemble the Dockerfile and build our image.\nFor all R projects, look no further than the Rocker project for all your base image needs. What is the best version will depend on this project, but my general direction is: if you use tidyverse anywhere, use the tidyverse image. Otherwise, use the rstudio image to have a GUI into your environment.\nNow, make sure you take a rocker image with the same R version as you. Then, let’s do our Dockerfile:\n\nFROM rocker/tidyverse:4.2.0\n# your renv version\nENV RENV_VERSION=0.15.4\nRUN apt-get update\n# install any Unix libraries after this, e.g. RUN apt-get update && apt-get install cmake\nRUN R \"install.packages('remotes', repos = repos = c(CRAN = 'https://cloud.r-project.org')\"\nRUN R \"remotes::install_github('rstudio/renv@${RENV_VERSION}')\"\nWORKDIR /project\nCOPY renv.lock renv.lock\nRUN R \"renv::restore()\"\n\nWrite this to a file called Dockerfile in the directory where your analysis is (you’ll see it included if you downloaded the project).\nNow navigate to the directory in the terminal and build it (this will take a while):\n\ndocker build -t csgroen/blog_example .\n\nMake sure you give it a relevant name under the -t (tag) flag. Here, I used my username on DockerHub and a name relevant to this post, i.e. username/image_name, so I can push this later to share.\nAnd that’s it, your environment is dockerized!\nIf you’d like to download the one I just made instead of building it, just pull it from Docker Hub:\n\ndocker pull csgroen/blog_example\n\n\n\nRunning the docker\nBefore we share it with the world, let’s re-run your analysis.\n\ndocker run --rm \\\n-v path/to/example:/home/rstudio/project \\\n-p 8787:8787 \\\n-e PASSWORD=somepassword \\\n-e USERID=$UID \\\ncsgroen/blog_example\n\nHere, we are mounting the “example” directory into the “project” directory of our image and preparing the password and username so we can use Rstudio server to connect to the image.\nMake sure you use the absolute path/to/example, e.g. /home/myuser/Downloads/example.\nOnce you run this, you’ll see this message, or something very similar:\n\n[s6-init] making user provided files available at /var/run/s6/etc...exited 0.\n[s6-init] ensuring user provided files have correct perms...exited 0.\n[fix-attrs.d] applying ownership & permissions fixes...\n[fix-attrs.d] done.\n[cont-init.d] executing container initialization scripts...\n[cont-init.d] 01_set_env: executing... \nskipping /var/run/s6/container_environment/HOME\nskipping /var/run/s6/container_environment/PASSWORD\nskipping /var/run/s6/container_environment/RSTUDIO_VERSION\n[cont-init.d] 01_set_env: exited 0.\n[cont-init.d] 02_userconf: executing... \ndeleting the default user\ncreating new rstudio with UID 1001\nuseradd: warning: the home directory /home/rstudio already exists.\nuseradd: Not copying any file from skel directory into it.\n[cont-init.d] 02_userconf: exited 0.\n[cont-init.d] done.\n[services.d] starting services\n[services.d] done.\n\nThis means Rstudio server is ready with your environment and your mounted data. Open your browser to localhost:8787. You’ll see this:\n\nSign-in with the credentials we created on docker run:\n\nUsername: rstudio\nPassword: somepassword\n\nYou’ll be signed into something like this:\n\nSee our project folder in the Files. Navigate there and you’ll see our sleep.R script. Open it and run it.\n\nAnd we’re done: we’ve been able to run the same analysis in the same environment we had when we wrote it.\n\n\nSharing\nNow that everything works, we can push our docker, and add the example (with the code and data) to Github. In this minimal example, we don’t have any additional data other than the script, but you could add that as well.\nCheck these instructions to push to Docker Hub.\nAnd then add your code/data to a repo on Github, like I did here. You don’t need to add the Dockerfile or renv.lock to Github.\nMake a README like this to teach others how to reproduce the analysis:\n\n# Minimal example of reproducible analysis\n\nTo run the analysis contained in `sleep.R` in the same environment it was created:\n\n1.  Pull the docker image from DockerHub:\n\ndocker pull csgroen/blog_example\n\n2.  Download this repo (e.g. git clone csgroen/blog_example)\n\n3.  Mount the repo into the docker image and run:\n\ndocker run --rm\\\n-v /path/to/example:/home/rstudio/project\\\n-p 8787:8787\\\n-e PASSWORD=somepassword\\\n-e USERID=\\$UID\\\ncsgroen/blog_example\n\nwhere /path/to/example is the absolute path to the repo.\n\n3.  Open Rstudio server by opening your browser and navigating to:\n\nlocalhost:8787\n\n4.  Sign-in username: rstudio password: somepassword.\n\n5.  Navigate to `/project`, open the `sleep.R` script and run it.\n\nNow celebrate achieving the gold standard of reproducibility, something very few are even attempting to do.\n\n\n\n\n\nFeel free to open issues and hit me up on the Github repo if you have any problems/questions! Toodaloo 👋🏻"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi, I’m Clarice Groeneveld and I’m currently a doctoral student at PSL Research University as a member of Radvanyi lab at Institut Curie and MEPPOT under Aurélien de Reyniès at Cordeliers Research Institute.\nI’m passionate about using molecular data to find biological insights that can lead to more treatment options for patients. I particularly love exploring and visualizing shiny new molecular data of all kinds for insights. I have experience with bulk epigenetic, transcriptomic and proteomic data, as well as single-cell experiments.\nI also strive to write and implement well thought-out and documented methods to do my research. I started this blog to share some code to help myself and others to carry out more reproducible research."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "Hi, I’m Clarice Groeneveld and I’m the director of the Cordeliers AI and Bioinformatics (CAIBI) Core Facility at the Cordeliers Research Center.\nPreviously, I was a post-doctoral fellow at MUST team in the Cordeliers and a earned my doctorate at PSL Research University as a member of Radvanyi lab at Institut Curie and CIT La Ligue under Aurélien de Reyniès.\nI’m passionate about using molecular data to find biological insights that can lead to more treatment options for patients. I particularly love exploring and visualizing shiny new molecular data of all kinds for insights, and creating tools to do it better, faster or in a more reproducible fashion. I have experience with bulk epigenetic, transcriptomic and proteomic data, as well as single-cell experiments, spatial transcriptomics and like to dip my toe into image analysis.\nI strive to write and implement well thought-out and documented methods to do my research, both methodological and scientific. I started this blog to share some code to help myself and others to carry out more reproducible research."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\n\nDoctorate (PSL Research University, Institut Curie and Cordeliers Research Center) | Sep 2020 - ongoing | Bladder cancer heterogeneity and TME.\nMasters (Bioinformatics, Federal University of Paraná) | Mar 2017 - Mar 2019 | Regulatory network analyses and framework development\nBEng Bioprocess Engineering and Biotechnology (Federal University of Paraná, study abroad at University of Sydney) | Mar 2010 - Jun 2016"
  },
  {
    "objectID": "about.html#publications",
    "href": "about.html#publications",
    "title": "About",
    "section": "Publications",
    "text": "Publications\nCheck out my full publication record on ORCID."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\n\nPost-Doc (Cordeliers Research Center, Université Paris-Cité) - Tumor microenvironment - Jul 2023 - ongoing\nDoctorate (PSL Research University, Institut Curie and Cordeliers Research Center) | Sep 2020 - Jul 2023 | Bladder cancer heterogeneity and TME.\nMasters (Bioinformatics, Federal University of Paraná) | Mar 2017 - Mar 2019 | Regulatory network analyses and framework development\nBEng Bioprocess Engineering and Biotechnology (Federal University of Paraná, study abroad at University of Sydney) | Mar 2010 - Jun 2016"
  },
  {
    "objectID": "index.html#publications",
    "href": "index.html#publications",
    "title": "About",
    "section": "Publications",
    "text": "Publications\nCheck out my full publication record on ORCID."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "R and Seurat to analyse single cell RNA-seq\n\n\nCase study - NKG2A and HLA-E define an alternative immune checkpoint axis in bladder cancer\n\n\n\n\n\n\n\n\nClarice Groeneveld\n\n\n\n\n\n\n\n\n\n\n\n\nSingle Cell Technologies and Analysis: Seurat and friends\n\n\n\n\n\n\n\n\n\n\n\nClarice S Groeneveld\n\n\n\n\n\n\n\n\n\n\n\n\ndeconverse: Deconvolution using scRNA-seq references\n\n\n\n\n\n\nr\n\n\npresentation\n\n\ndeconverse\n\n\n\n\n\n\n\n\n\nOct 26, 2023\n\n\nClarice S Groeneveld\n\n\n\n\n\n\n\n\n\n\n\n\nDockerizing my R environment for reproducibility\n\n\n\n\n\n\nr\n\n\ntutorial\n\n\ndocker\n\n\n\nAre you tired of package updates changing your outputs? This one is for you\n\n\n\n\n\nMay 2, 2022\n\n\nClarice S Groeneveld\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#what-is-deconvolution",
    "href": "posts/deconverse_bioinfoclub/index.html#what-is-deconvolution",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "What is deconvolution?",
    "text": "What is deconvolution?\nThe goal of deconvolution is to predict the makeup of a mixture in terms of its components and their fractions. i.e. if:\n\n\nMixture: bulk RNA-seq profiles (bulk, spot on a 10X Visium)\nComponents: cell type profiles (C)\n\nthen \\(mixture = \\sum_{i=1}^{n} C_iw_i\\) subject to: \\(\\sum_{i=1}^n w_i = 1\\) and \\(w_i \\geq 0\\)"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconvolution-graphical-summary",
    "href": "posts/deconverse_bioinfoclub/index.html#deconvolution-graphical-summary",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Deconvolution graphical summary",
    "text": "Deconvolution graphical summary"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#why-is-it-useful",
    "href": "posts/deconverse_bioinfoclub/index.html#why-is-it-useful",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Why is it useful?",
    "text": "Why is it useful?\nGoal: define the cell types and their proportions present in a sample\n\nIdentify and understand tissue heterogeneity\nAssociate cell types with clinical variables (e.g. survival, response to therapy)\nApply to downstream analysis: e.g. cell-to-cell communication"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#challenges-of-deconvolution",
    "href": "posts/deconverse_bioinfoclub/index.html#challenges-of-deconvolution",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Challenges of deconvolution",
    "text": "Challenges of deconvolution\nIf \\(mixture = \\sum_{i=1}^{n} C_iw_i\\), subject to: \\(\\sum_{i=1}^n w_i = 1\\) and \\(w_i \\geq 0\\)\n\n\nFor the user:\n\nWhat are the cell types present and how many are there?\nWhat is a good reference for my mixture?\n\nFor the method:\n\nAssumption: all cell types that could be present are represented in the reference\nHow do I identify the cell type profiles (C)? In what space?\nHow do I measure if I have a good fit?"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#tme-deconvolution-first-generation",
    "href": "posts/deconverse_bioinfoclub/index.html#tme-deconvolution-first-generation",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "TME deconvolution: first generation",
    "text": "TME deconvolution: first generation\nFirst generation deconvolution methods generally used FACS-sorted gene expression as cell type profiles, often from PBMCs. References are almost always pre-computed."
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#tme-deconvolution-examples-of-first-generation-methods",
    "href": "posts/deconverse_bioinfoclub/index.html#tme-deconvolution-examples-of-first-generation-methods",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "TME deconvolution: examples of first generation methods",
    "text": "TME deconvolution: examples of first generation methods\n\nCIBERSORT (support vector regression)\nMCPcounter (marker mean expression)\nxCell (corrected ssgsea)\nEPIC and quanTiSeq (constrained least square minimization)\n\nSome methods don’t do deconvolution per se (don’t return proportions): inter-sample comparisons only\nMethods don’t assume a complete reference: only deconvolute cell types of the TME"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#cell-type-deconvolution-second-generation",
    "href": "posts/deconverse_bioinfoclub/index.html#cell-type-deconvolution-second-generation",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Cell type deconvolution: second-generation",
    "text": "Cell type deconvolution: second-generation\n(User-provided) single-cell reference of the same context as the sample to be deconvoluted"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#the-single-cell-reference-atlases",
    "href": "posts/deconverse_bioinfoclub/index.html#the-single-cell-reference-atlases",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "The single cell reference: atlases",
    "text": "The single cell reference: atlases\n\nTabula Muris\nTabula Sapiens\nHuman Lung Atlas\nMultiple published single-cell atlases of different tissues or pathologies\n. . .\n\nMajor problem: cell-type annotation"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#example-colon-atlas-pelka-et-al.-2021",
    "href": "posts/deconverse_bioinfoclub/index.html#example-colon-atlas-pelka-et-al.-2021",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Example: Colon Atlas (Pelka et al., 2021)",
    "text": "Example: Colon Atlas (Pelka et al., 2021)\nCoarse-grained annotation\n\n\n\n\n\n\nFine-grained annotation of compartments"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#cell-type-resolution-can-we-separate-them",
    "href": "posts/deconverse_bioinfoclub/index.html#cell-type-resolution-can-we-separate-them",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Cell type resolution: can we separate them?",
    "text": "Cell type resolution: can we separate them?\n\n\n\nDeconvolution methods are often robust when using coarse-grained annotation\nDeconvolution often fails at separating cell types defined by ‘state’ (e.g. T CD4+/CD8+, B-naive from B-mature)\nWhat is the appropriate “level” of annotation that allows for deconvolution?"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconverse-a-meta-method-package-with-benchmarking-built-in",
    "href": "posts/deconverse_bioinfoclub/index.html#deconverse-a-meta-method-package-with-benchmarking-built-in",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "deconverse: a meta-method package with benchmarking built-in",
    "text": "deconverse: a meta-method package with benchmarking built-in"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconvolution-methods-in-deconverse",
    "href": "posts/deconverse_bioinfoclub/index.html#deconvolution-methods-in-deconverse",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Deconvolution methods in deconverse",
    "text": "Deconvolution methods in deconverse\n\ndeconvolution_methods()\n\n         OLS         DWLS          SVR   CIBERSORTx        MuSiC   BayesPrism \n       \"ols\"       \"dwls\"        \"svr\" \"cibersortx\"      \"music\" \"bayesprism\" \n      Bisque    AutoGeneS       scaden         CARD         RCTD    SPOTlight \n    \"bisque\"  \"autogenes\"     \"scaden\"       \"card\"       \"rctd\"  \"spotlight\" \n\n\n\nspatial_only_methods()\n\n       CARD        RCTD   SPOTlight \n     \"card\"      \"rctd\" \"spotlight\""
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconverse-ideas",
    "href": "posts/deconverse_bioinfoclub/index.html#deconverse-ideas",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "deconverse ideas",
    "text": "deconverse ideas\nScientific\n\n\nSupport for multiple levels of annotation at the same time\nCorrection of finer grained annotation by coarser-grained\nAid users in detecting what level of annotation is appropriate through benchmarking\n\n\nTechnical\n\n\nAny method: same syntax\nRun multiple methods with one command\nA general framework: adding new methods is easy"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconverse-syntax-screference",
    "href": "posts/deconverse_bioinfoclub/index.html#deconverse-syntax-screference",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "deconverse syntax: screference",
    "text": "deconverse syntax: screference\nSingle-cell (hierarchycal) reference\n\npbmc_ref &lt;- new_hscreference(pbmc_train,\n                annot_ids = c(\"Cell_major_identities\", \"Cell_minor_identities\"),\n                project_name = \"pbmc_example\",\n                batch_id = \"orig.ident\")\n\n\npbmc_ref &lt;- pbmc_ref |&gt;\n    compute_reference(\"dwls\") |&gt;\n    compute_reference(\"autogenes\")"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconverse-syntax-deconvolute",
    "href": "posts/deconverse_bioinfoclub/index.html#deconverse-syntax-deconvolute",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "deconverse syntax: deconvolute",
    "text": "deconverse syntax: deconvolute\n\ndeconv_res &lt;- deconvolute_all(gexp, pbmc_ref,\n                              methods = c(\"dwls\", \"ols\", \"svr\"))"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconverse-syntax-scbench",
    "href": "posts/deconverse_bioinfoclub/index.html#deconverse-syntax-scbench",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "deconverse syntax: scbench",
    "text": "deconverse syntax: scbench\n\npbmc_bench &lt;- new_scbench(pbmc_test, \n                         annot_ids = c(\"Cell_major_identities\",\n                                       \"Cell_minor_identities\"),\n                         project_name = \"pbmc_example\",\n                         batch_id = \"orig.ident\")\n\nGenerate “mixtures” for each benchmarking test (bounds can be given)\n\npbmc_bench &lt;- pbmc_bench |&gt;\n    mixtures_population(nsamp = 500) |&gt;\n    mixtures_lod() |&gt;\n    mixtures_spillover()"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconverse-syntax-scbench-1",
    "href": "posts/deconverse_bioinfoclub/index.html#deconverse-syntax-scbench-1",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "deconverse syntax: scbench",
    "text": "deconverse syntax: scbench\nCreates pseudobulk samples from the single-cell profiles in pbmc_test\n\npbmc_bench &lt;- pseudobulks(pbmc_bench, ncells = 1000)\n\n\npbmc_bench &lt;- deconvolute_all(pbmc_bench, pbmc_ref,\n                              methods = c(\"dwls\", \"svr\", \"ols\", \n                                          \"autogenes\", \"bisque\"))"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconverse-benchmarking-results-population",
    "href": "posts/deconverse_bioinfoclub/index.html#deconverse-benchmarking-results-population",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "deconverse benchmarking results: population",
    "text": "deconverse benchmarking results: population\n\nplt_cors_scatter(pbmc_bench, method = \"dwls\")"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconverse-benchmarking-results-compare-between-populations",
    "href": "posts/deconverse_bioinfoclub/index.html#deconverse-benchmarking-results-compare-between-populations",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "deconverse benchmarking results: compare between populations",
    "text": "deconverse benchmarking results: compare between populations\n\nplt_cor_heatmap(pbmc_bench, level = \"l2\")$heatmap"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconverse-benchmarking-results-spillover",
    "href": "posts/deconverse_bioinfoclub/index.html#deconverse-benchmarking-results-spillover",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "deconverse benchmarking results: spillover",
    "text": "deconverse benchmarking results: spillover\n\nplt_spillover_heatmap(pbmc_bench)$heatmap"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#deconverse-benchmarking-results-limit-of-detection",
    "href": "posts/deconverse_bioinfoclub/index.html#deconverse-benchmarking-results-limit-of-detection",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "deconverse benchmarking results: limit of detection",
    "text": "deconverse benchmarking results: limit of detection\n\nplt_lod_heatmap(pbmc_bench)$heatmap"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#some-details-deconvolution-methods-in-deconverse",
    "href": "posts/deconverse_bioinfoclub/index.html#some-details-deconvolution-methods-in-deconverse",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Some details: Deconvolution methods in deconverse",
    "text": "Some details: Deconvolution methods in deconverse\n\n\nOrdinary Least Squares (OLS), Support Vector (SVR) and Dampened Weighted Least Squares Regressions use the same reference cell marker matrix from Seurat::findMarkers\nCIBERSORTx runs in a docker\nMuSiC and DWLS were reimplemented for performance\n(Python) Reticulate methods: AutoGeneS and scaden"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#spatial-deconvolution-methods-to-be-added-to-deconverse-0.3",
    "href": "posts/deconverse_bioinfoclub/index.html#spatial-deconvolution-methods-to-be-added-to-deconverse-0.3",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Spatial deconvolution methods to be added to deconverse 0.3",
    "text": "Spatial deconvolution methods to be added to deconverse 0.3\nSame syntax, any method:\n\nscref &lt;- new_screference(kidney_so,\n                                annot_id = c(\"compartment\"),\n                                project_name = \"kidney\",\n                                batch_id = \"donor\")\nscref &lt;- compute_reference(scref, method = \"card\")\n\n\nspatial_obj &lt;- deconvolute(spatial_obj, scref, method = \"rctd\")"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#example-of-spatial-deconvolution-results",
    "href": "posts/deconverse_bioinfoclub/index.html#example-of-spatial-deconvolution-results",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Example of spatial deconvolution results",
    "text": "Example of spatial deconvolution results\n\nSpatialFeaturePlot(spatial_obj,\n                   features = deconverse_results(spatial_obj, method = \"rctd\")[[1]],\n                   pt.size.factor = 1.3)"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#example-of-spatial-deconvolution-results-1",
    "href": "posts/deconverse_bioinfoclub/index.html#example-of-spatial-deconvolution-results-1",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Example of spatial deconvolution results",
    "text": "Example of spatial deconvolution results\n\nSpatialDimPlot(spatial_obj, \n               group.by = deconverse_results(spatial_obj, method = \"rctd\", major_population = TRUE)[1], \n               pt.size.factor = 1.3)"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#new-methodology-for-spatial-deconvolution",
    "href": "posts/deconverse_bioinfoclub/index.html#new-methodology-for-spatial-deconvolution",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "New methodology for spatial deconvolution?",
    "text": "New methodology for spatial deconvolution?\nNot all current “spatial specific” methods use spatial information on deconvolution:\n\nUse spatial information: CARD, cell2location\nDon’t use: SPOTlight, RCTD, DestVI\n\n\nGraph-based? e.g. graph-NMF followed by NNLS"
  },
  {
    "objectID": "posts/deconverse_bioinfoclub/index.html#thanks",
    "href": "posts/deconverse_bioinfoclub/index.html#thanks",
    "title": "deconverse: Deconvolution using scRNA-seq references",
    "section": "Thanks!",
    "text": "Thanks!\nEmail 📧 clarice.groeneveld@inserm.fr\nGithub 😺 csgroen\nBlueSky (bye-bye X) 🟦 csgroen\nTry Deconverse: github.com/csgroen/deconverse\nPresentation available at: csgroen.github.io/posts/deconverse_bioinfoclub"
  },
  {
    "objectID": "posts/intro_seurat_du/index.html#why-single-cell",
    "href": "posts/intro_seurat_du/index.html#why-single-cell",
    "title": "Single Cell Technologies and Analysis: Seurat and friends",
    "section": "Why Single Cell?",
    "text": "Why Single Cell?\n Identify biomarkers of cell types and states\n Capture full heterogeneity in a sample\n Track changes in states: development, disease progression, immune responses\n Explore cell-to-cell interactions"
  },
  {
    "objectID": "posts/intro_seurat_du/index.html#how-to-choose-a-method",
    "href": "posts/intro_seurat_du/index.html#how-to-choose-a-method",
    "title": "Single Cell Technologies and Analysis: Seurat and friends",
    "section": "How to choose a method?",
    "text": "How to choose a method?\n\n\n\nDing, J. et al. Systematic comparison of single-cell and single-nucleus RNA-sequencing methods. Nat Biotechnol 38, 737–746 (2020)."
  },
  {
    "objectID": "posts/intro_seurat_du/index.html#how-to-choose-a-method-number-of-umi-genes",
    "href": "posts/intro_seurat_du/index.html#how-to-choose-a-method-number-of-umi-genes",
    "title": "Single Cell Technologies and Analysis: Seurat and friends",
    "section": "How to choose a method? Number of UMI / Genes",
    "text": "How to choose a method? Number of UMI / Genes\n\n\n\nDing, J. et al. Systematic comparison of single-cell and single-nucleus RNA-sequencing methods. Nat Biotechnol 38, 737–746 (2020)."
  },
  {
    "objectID": "posts/intro_seurat_du/index.html#how-to-choose-a-method-considerations",
    "href": "posts/intro_seurat_du/index.html#how-to-choose-a-method-considerations",
    "title": "Single Cell Technologies and Analysis: Seurat and friends",
    "section": "How to choose a method: considerations",
    "text": "How to choose a method: considerations\n\n10x Chromium had the strongest consistent performance: high sensitivity, fastest\nLowest costs: Drop-seq, Seq-Well and inDrops\nHigh sensitivity: both low-throughput methods (Smart-seq2 and CEL-Seq2)\nSmart-seq2: full-length transcript allows for splicing isoforms and variant detection\n\n\n\nDing, J. et al. Systematic comparison of single-cell and single-nucleus RNA-sequencing methods. Nat Biotechnol 38, 737–746 (2020)."
  },
  {
    "objectID": "posts/intro_seurat_du/index.html#scrna-seq-computational-pre-processing",
    "href": "posts/intro_seurat_du/index.html#scrna-seq-computational-pre-processing",
    "title": "Single Cell Technologies and Analysis: Seurat and friends",
    "section": "scRNA-seq computational pre-processing",
    "text": "scRNA-seq computational pre-processing\nFor 10X: Cell Ranger (https://www.10xgenomics.com/support/software/cell-ranger/latest/algorithms-overview/cr-3p-cellplex-algorithm)\nOthers: Alevin (Salmon), Kallisto BUStools (kb), STARsolo\n\nCMO: Cell Multiplexing Oligo tags\nGEX: Gene expression"
  },
  {
    "objectID": "posts/intro_seurat_du/index.html#cellranger-demultiplexing",
    "href": "posts/intro_seurat_du/index.html#cellranger-demultiplexing",
    "title": "Single Cell Technologies and Analysis: Seurat and friends",
    "section": "cellranger demultiplexing",
    "text": "cellranger demultiplexing\n\nExpectation-Maximization (EM) algorithm of the parameters of the Gaussians and state assignments"
  },
  {
    "objectID": "posts/intro_seurat_du/index.html#new-cellranger-annotate",
    "href": "posts/intro_seurat_du/index.html#new-cellranger-annotate",
    "title": "Single Cell Technologies and Analysis: Seurat and friends",
    "section": "New! cellranger annotate",
    "text": "New! cellranger annotate"
  },
  {
    "objectID": "posts/intro_seurat_du/index.html#analysis-library-families",
    "href": "posts/intro_seurat_du/index.html#analysis-library-families",
    "title": "Single Cell Technologies and Analysis: Seurat and friends",
    "section": "Analysis library families",
    "text": "Analysis library families\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSeurat\nBioconductor\nscverse\n\n\n\n\nProgramming Language\nR\nR\nPython\n\n\nCore Data Structure\nSeurat object\nSingleCellExperiment\nAnnData\n\n\nEcosystem\nIntegrated all-in-one “pipeline”\nModular via Bioconductor packages\nModular, interoperable toolkit\n\n\nVisualization\nExtensive built-in plotting functions\nVisualization via scatter + ggplot2\nscanpy + MPL / seaborn\n\n\nCommunity & Support\nLarge, active community\nBioconductor project\nGrowing, active Python 3community"
  },
  {
    "objectID": "posts/intro_seurat_du/index.html#state-of-the-art-single-cell-with-seurat",
    "href": "posts/intro_seurat_du/index.html#state-of-the-art-single-cell-with-seurat",
    "title": "Single Cell Technologies and Analysis: Seurat and friends",
    "section": "State-of-the art single-cell with Seurat",
    "text": "State-of-the art single-cell with Seurat\n\nFollow me to the tutorial: csgroen.io/blog/tutorial_seurat_du"
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html",
    "href": "posts/tutorial_seurat_du/intro.html",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "",
    "text": "Download this notebook: https://raw.githubusercontent.com/csgroen/teaching/refs/heads/main/20250214_Tutorial_DU_Seurat.qmd"
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#pre-requisites",
    "href": "posts/tutorial_seurat_du/intro.html#pre-requisites",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Pre-requisites",
    "text": "Pre-requisites\nFor the best understanding of this tutorial, please make sure you have at least an intermediate understanding of R. Here are some recommended resources to learn the basics and necessary intermediate concepts:\n\nswirl: https://swirlstats.com/students.html\n\nSpecifically courses R Programming, Getting and Cleaning Data and Exploratory Data Analysis may provide a good jump start.\n\nHands On Programming with R: https://rstudio-education.github.io/hopr/\n\nThe very basics of R programming as also explained in this thorough book from the Posit team (that builds RStudio).\n\nR for Data Science: https://r4ds.hadley.nz/\n\nThis goes further than we need, but a base for most of the programming questions a data analyst working in R could have to start with."
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#resources",
    "href": "posts/tutorial_seurat_du/intro.html#resources",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Resources",
    "text": "Resources\nSeurat has many very useful tutorials for all of its features. Elements of this case study were taken from the following:\n\nSeurat - Guided Clustering Tutorial https://satijalab.org/seurat/archive/v3.0/pbmc3k_tutorial.html\nIntroduction to scRNA-seq integration: https://satijalab.org/seurat/articles/integration_introduction\nMapping and annotating query datasets: https://satijalab.org/seurat/articles/integration_mapping"
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#install-packages",
    "href": "posts/tutorial_seurat_du/intro.html#install-packages",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Install packages",
    "text": "Install packages\nTo ensure we have all installed libraries, we’ll use R package “pacman”, which allows us to check if packages are not installed and load them. This is not a replacement for more comprehensive version control (e.g. using renv), but it’s simple to install and very lightweight.\n\n\nCode\nif(! \"pacman\" %in% installed.packages()) install.packages(\"pacman\")\npacman::p_load(\"Seurat\", \"tidyverse\", \"R.utils\", \"ggpubr\", \"patchwork\", \n               \"celldex\", \"SingleR\", \"scRNAseq\", \"pheatmap\",\n               \"ggsci\", \"scds\")\n\n\nI’m personally not a big fan of the standard look of Seurat plots, so I’ll apply this ggplot2 theme to (almost) all Seurat plots we generate:\n\n\nCode\ntheme_clean &lt;-\n  theme_linedraw() +\n  theme(panel.grid = element_blank(),\n        panel.border = element_blank(),\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n\n\n\nNote: Seurat plots are ggplot-based and therefore can be “added to” in a grammar-of-graphics manner. Plots for multiple features are patchworks, which use a slightly different syntax to add to (this is why sometimes you’ll see & instead of + being used)."
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#download-data",
    "href": "posts/tutorial_seurat_du/intro.html#download-data",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Download data",
    "text": "Download data\nOur dataset comes from Salomé et al (2022) [https://www.sciencedirect.com/science/article/pii/S1535610822003695], “NKG2A and HLA-E define an alternative immune checkpoint axis in bladder cancer”. This single-cell data is a bit particular: they have FACS-sorted their cells into CD45+ and CD45-, notably to enrich their dataset in hematopoetic cells.\nWe’ll download the data from the link provided in the article:\n\n\nCode\ndir.create(\"data\")\ndownload.file(\"https://prod-dcd-datasets-cache-zipfiles.s3.eu-west-1.amazonaws.com/7yb7s9769c-1.zip\", 'data/Salome_2022.zip')\nunzip('data/Salome_2022.zip', exdir = \"data\")"
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#read-10x-data",
    "href": "posts/tutorial_seurat_du/intro.html#read-10x-data",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Read 10X data",
    "text": "Read 10X data\n\n\nCode\nref_dir &lt;- \"data/NKG2A and HLA-E define an alternative immune checkpoint axis in bladder cancer/\"\nlist.files(ref_dir)\n\n\n [1] \"385_Patient49_CD45pos\" \"394_Patient50_CD45pos\" \"397_Patient51_CD45pos\"\n [4] \"421_Patient52_CD45pos\" \"434_Patient53_CD45pos\" \"435_Patient54_CD45pos\"\n [7] \"453_Patient01_CD45pos\" \"454_Patient01_CD45neg\" \"456_Patient02_CD45pos\"\n[10] \"457_Patient02_CD45neg\" \"584_Patient03_bulk\"    \"595_Patient04_bulk\"   \n[13] \"613_Patient55_bulk\"    \"651_Patient05_bulk\"    \"656_Patient06_bulk\"   \n[16] \"663_Patient07_bulk\"    \"695_Patient08_bulk\"   \n\n\nWe can see the data is distributed as one folder per dataset, and includes the bulk data, which we’re not going to use. For this reason, I will filter out the “bulk” folders and to get my vector of sc_dts (single-cell datasets).\n\n\nCode\nsc_dts &lt;- ref_dir |&gt; list.files() |&gt; str_subset(\"bulk\", negate = TRUE)\nsc_dts\n\n\n [1] \"385_Patient49_CD45pos\" \"394_Patient50_CD45pos\" \"397_Patient51_CD45pos\"\n [4] \"421_Patient52_CD45pos\" \"434_Patient53_CD45pos\" \"435_Patient54_CD45pos\"\n [7] \"453_Patient01_CD45pos\" \"454_Patient01_CD45neg\" \"456_Patient02_CD45pos\"\n[10] \"457_Patient02_CD45neg\"\n\n\n\nSyntax note: ref_dir |&gt; list.files() |&gt; str_subset(\"bulk\", negate = TRUE) is equivalent to str_subset(list.files(ref_dir), \"bulk\", negate = TRUE). The |&gt; was first introduced as %&gt;% from R package magrittr and officially incorporated into base R&gt;=4.0. It’s purpose is to increase code legibility through “chaining” commands instead of “nesting” them. If you would like to learn more, you can check the help file ? |&gt;\n\nWe can check inside each folder:\n\n\nCode\nref_dir |&gt; filePath(sc_dts[1]) |&gt; list.files()\n\n\n[1] \"barcodes.tsv.gz\" \"features.tsv.gz\" \"matrix.mtx.gz\"  \n\n\nThis is a common export of single-cell data and can be read directly into Seurat using function Read10X.\nThis snippet will read all of our samples at once:\n\n\nCode\nread_exp_sample &lt;- function(sc_file) {\n  message('Reading file: ', sc_file)\n  so &lt;- ref_dir |&gt; filePath(sc_file) |&gt; Read10X()\n  so &lt;- CreateSeuratObject(so, project = \"BLCA_NKG2A\")\n  so[[\"sample\"]] &lt;- str_remove(sc_file, \"^.{4}\")\n  so[[\"patient\"]] &lt;- str_extract(sc_file, \"Patient..\")\n  so[[\"CD45\"]] &lt;- str_extract(sc_file, \"(?&lt;=CD45).*\")\n  return(so)\n}\n\nsc_data &lt;- lapply(sc_dts, read_exp_sample)\n\n\nReading file: 385_Patient49_CD45pos\n\n\nReading file: 394_Patient50_CD45pos\n\n\nReading file: 397_Patient51_CD45pos\n\n\nReading file: 421_Patient52_CD45pos\n\n\nReading file: 434_Patient53_CD45pos\n\n\nReading file: 435_Patient54_CD45pos\n\n\nReading file: 453_Patient01_CD45pos\n\n\nReading file: 454_Patient01_CD45neg\n\n\nReading file: 456_Patient02_CD45pos\n\n\nReading file: 457_Patient02_CD45neg\n\n\nCode\nnames(sc_data) &lt;- sc_dts\n\n\n\nMerge samples\nThe script we ran generated 10 Seurat objects, which we will merge into one for further analysis. Each count matrix, at first, will be stored as a Layer in our Seurat object.\n\n\nCode\nsc_data &lt;- merge(sc_data[[1]], sc_data[2:length(sc_data)])\n\n\nWarning: Some cell names are duplicated across objects provided. Renaming to\nenforce unique cell names."
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#seurat-syntax-basics-for-object-accession",
    "href": "posts/tutorial_seurat_du/intro.html#seurat-syntax-basics-for-object-accession",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Seurat syntax basics for object accession",
    "text": "Seurat syntax basics for object accession\nHere are some “essential commands” for accession of information inside the Seurat object :https://satijalab.org/seurat/articles/essential_commands.html.\nThe document also outlines the “basic pipeline”.\nTo see some general info about the object, we can just print it:\n\n\nCode\nsc_data\n\n\nAn object of class Seurat \n33538 features across 50940 samples within 1 assay \nActive assay: RNA (33538 features, 0 variable features)\n 10 layers present: counts.1, counts.2, counts.3, counts.4, counts.5, counts.6, counts.7, counts.8, counts.9, counts.10\n\n\nNote the layers, for the different samples. We can also see what analyses have been run in this object (none yet).\n\nCell metadata\n[[]] allows us to access the cell metadata in a concise manner:\n\n\nCode\nsc_data[[]] |&gt; head()\n\n\n                     orig.ident nCount_RNA nFeature_RNA            sample\nAAACCTGAGGCCCTCA-1_1 BLCA_NKG2A       4917         1671 Patient49_CD45pos\nAAACCTGAGTTCGCGC-1_1 BLCA_NKG2A        891          369 Patient49_CD45pos\nAAACCTGCACTGTTAG-1_1 BLCA_NKG2A       1121          606 Patient49_CD45pos\nAAACCTGCAGACGCTC-1_1 BLCA_NKG2A       3877         1484 Patient49_CD45pos\nAAACCTGGTACAGCAG-1_1 BLCA_NKG2A       1393          552 Patient49_CD45pos\nAAACCTGGTCACACGC-1_1 BLCA_NKG2A       1491          709 Patient49_CD45pos\n                       patient CD45\nAAACCTGAGGCCCTCA-1_1 Patient49  pos\nAAACCTGAGTTCGCGC-1_1 Patient49  pos\nAAACCTGCACTGTTAG-1_1 Patient49  pos\nAAACCTGCAGACGCTC-1_1 Patient49  pos\nAAACCTGGTACAGCAG-1_1 Patient49  pos\nAAACCTGGTCACACGC-1_1 Patient49  pos\n\n\n\n\nAssay matrix (e.g. counts)\nTo get matrices from the Seurat objects, there are many “official” ways, but one of these two, which have exactly the same output, should work well:\n\n\nCode\nGetAssayData(sc_data, layer = \"counts.1\")[1:5,1:5]\n\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n            AAACCTGAGGCCCTCA-1_1 AAACCTGAGTTCGCGC-1_1 AAACCTGCACTGTTAG-1_1\nMIR1302-2HG                    .                    .                    .\nFAM138A                        .                    .                    .\nOR4F5                          .                    .                    .\nAL627309.1                     .                    .                    .\nAL627309.3                     .                    .                    .\n            AAACCTGCAGACGCTC-1_1 AAACCTGGTACAGCAG-1_1\nMIR1302-2HG                    .                    .\nFAM138A                        .                    .\nOR4F5                          .                    .\nAL627309.1                     .                    .\nAL627309.3                     .                    .\n\n\nCode\nsc_data[[\"RNA\"]]$counts.1[1:5,1:5]\n\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n            AAACCTGAGGCCCTCA-1_1 AAACCTGAGTTCGCGC-1_1 AAACCTGCACTGTTAG-1_1\nMIR1302-2HG                    .                    .                    .\nFAM138A                        .                    .                    .\nOR4F5                          .                    .                    .\nAL627309.1                     .                    .                    .\nAL627309.3                     .                    .                    .\n            AAACCTGCAGACGCTC-1_1 AAACCTGGTACAGCAG-1_1\nMIR1302-2HG                    .                    .\nFAM138A                        .                    .\nOR4F5                          .                    .\nAL627309.1                     .                    .\nAL627309.3                     .                    .\n\n\n\n\nUMI ids\nTo get the “ids” of the cells, we can simply call:\n\n\nCode\nCells(sc_data)[1:5]\n\n\n[1] \"AAACCTGAGGCCCTCA-1_1\" \"AAACCTGAGTTCGCGC-1_1\" \"AAACCTGCACTGTTAG-1_1\"\n[4] \"AAACCTGCAGACGCTC-1_1\" \"AAACCTGGTACAGCAG-1_1\"\n\n\n\n\nFeatures\nFor a single-cell RNA-seq object, we can see the genes (features) like so:\n\n\nCode\nFeatures(sc_data)[1:5]\n\n\n[1] \"MIR1302-2HG\" \"FAM138A\"     \"OR4F5\"       \"AL627309.1\"  \"AL627309.3\""
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#pre-processing-workflow",
    "href": "posts/tutorial_seurat_du/intro.html#pre-processing-workflow",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Pre-processing workflow",
    "text": "Pre-processing workflow\nThere are very standard steps for pre-processing, but that require some level of decision on the part of the user. The basic tutorial of Seurat, on PBMCs, covers this in detail: https://satijalab.org/seurat/articles/pbmc3k_tutorial\n\nQC and selecting cells for further analysis\nThis command will figure out the percentage of reads of mitchondrial RNA:\n\n\nCode\nsc_data[[\"percent.mt\"]] &lt;- PercentageFeatureSet(sc_data, pattern = \"^MT-\")\n\n\nThere are three major pieces of information we’d like to check to make filtering decisions: number of expressed features, number of reads and the percentage of mitochondrial RNA. Here, I plot per sample:\n\n\nCode\n(VlnPlot(sc_data, \n        features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), \n        group.by = \"sample\",\n        alpha = 0.3, \n        ncol = 3) &\n  theme_clean) +\n  plot_layout(guides = \"collect\")\n\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\n\nWe can also plot this for a particular known variable. For example, here I show for whether the cells were FACS-sorted as CD45 positive or negative:\n\n\nCode\n(VlnPlot(sc_data, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), \n         alpha = 0.3,\n         group.by = \"CD45\", ncol = 3) &\n  stat_compare_means() &\n  theme_clean) +\n  plot_layout(guides = \"collect\") +\n  plot_annotation(title = \"CD45\")\n\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\n\n\n\nFiltering and Normalization\nWe’ll reproduce the filtering and normalization steps proposed by the paper as closely as possible:\n\nFor each sample, cells were first selected as expressing less than 16–20% mitochondrial genes and displaying a minimum of 200–300 and a maximum of 2500–3500 features.\n\nAs we’re standardizing pre-processing for all samples, we’ll take the least stringent:\n\n\nCode\nsc_data &lt;- subset(sc_data, subset = nFeature_RNA &gt; 200 & nFeature_RNA &lt; 3500 & percent.mt &lt; 20)\n\n\n\nData were then log-normalized using a scale factor of 10,000.\n\n\n\nCode\nsc_data &lt;- NormalizeData(sc_data, normalization.method = \"LogNormalize\", scale.factor = 1e4)\n\n\nNormalizing layer: counts.1\n\n\nNormalizing layer: counts.2\n\n\nNormalizing layer: counts.3\n\n\nNormalizing layer: counts.4\n\n\nNormalizing layer: counts.5\n\n\nNormalizing layer: counts.6\n\n\nNormalizing layer: counts.7\n\n\nNormalizing layer: counts.8\n\n\nNormalizing layer: counts.9\n\n\nNormalizing layer: counts.10\n\n\n\n\nFeature selection and PCA\n\nThe 2,000 most variable features were then identified, data were scaled based on all the features […]\n\n\n\nCode\nsc_data &lt;- FindVariableFeatures(sc_data, nfeatures = 2000)\n\n\nFinding variable features for layer counts.1\n\n\nFinding variable features for layer counts.2\n\n\nFinding variable features for layer counts.3\n\n\nFinding variable features for layer counts.4\n\n\nFinding variable features for layer counts.5\n\n\nFinding variable features for layer counts.6\n\n\nFinding variable features for layer counts.7\n\n\nFinding variable features for layer counts.8\n\n\nFinding variable features for layer counts.9\n\n\nFinding variable features for layer counts.10\n\n\nCode\nsc_data &lt;- ScaleData(sc_data, features = rownames(sc_data))\n\n\nCentering and scaling data matrix\n\n\n\n[…] and principal component analysis was performed.\n\n\n\nCode\nsc_data &lt;- RunPCA(sc_data)\n\n\nPC_ 1 \nPositive:  S100P, SPINK1, KRT18, ADIRF, PSCA, KRT8, KRT19, MGST1, GDF15, KLF5 \n       CD24, HPGD, DHRS2, HES1, VSIG2, SDC4, SMIM22, C19orf33, SLPI, S100A6 \n       AGR2, SPINT2, TNFAIP2, GPRC5A, TSPAN6, S100A13, CLDN7, CD9, EFNA1, WFDC2 \nNegative:  CD52, IGKC, LAPTM5, RGS1, S100A4, IGLC2, IL32, CD3D, CD74, IGHA1 \n       IGHG1, CD69, LSP1, HSPA1A, VIM, LTB, CCL5, TRBC2, HLA-DPB1, COTL1 \n       IGLC3, ALOX5AP, TRBC1, IGHG2, GPR183, RGS2, GZMA, TYROBP, NKG7, CD7 \nPC_ 2 \nPositive:  SPARC, IGFBP7, CALD1, COL1A2, COL3A1, COL6A2, COL4A1, IFITM3, MYL9, COL1A1 \n       FN1, TPM2, CAVIN3, THY1, BGN, FSTL1, COX7A1, TIMP1, COL6A1, DCN \n       C1S, TAGLN, C1R, RGS5, COL5A2, LGALS1, SPARCL1, MFGE8, CTGF, COL6A3 \nNegative:  HPGD, GATA3, CD24, S100P, RAB11FIP1, CD3D, SPINK1, PSCA, DHRS2, KRT8 \n       KRT19, KLF5, CD52, UPK2, TRBC2, TMEM97, GDPD3, GDF15, TMPRSS2, VSIG2 \n       UPK1A, SDC4, KRT20, SMIM22, SPTSSB, MGST1, CNGA1, WFDC2, CXADR, UPK3A \nPC_ 3 \nPositive:  CALD1, SPARC, COL3A1, COL6A2, COL1A2, IGFBP7, IL32, COL4A1, COL1A1, RGS5 \n       THY1, MYL9, TPM2, SELENOM, CAVIN3, COL6A1, FSTL1, SOD3, MFGE8, BGN \n       COL5A2, COX7A1, MGP, COL6A3, NDUFA4L2, SPARCL1, PCOLCE, CTGF, C1R, LHFPL6 \nNegative:  TYROBP, FCER1G, LYZ, MS4A6A, CD14, HLA-DRA, FTL, CTSS, CD68, C1QC \n       C1QA, C1QB, MS4A7, FCGR2A, SPI1, OLR1, LST1, MS4A4A, C5AR1, PSAP \n       HLA-DRB5, SERPINA1, APOC1, CTSB, CST3, SAT1, CD163, HLA-DPA1, BCL2A1, HLA-DMA \nPC_ 4 \nPositive:  RAMP2, PCAT19, VWF, CLEC14A, HSPG2, EGFL7, RAMP3, CALCRL, AQP1, ECSCR \n       PCDH17, PODXL, FLT1, CD34, CDH5, VWA1, FAM167B, CLDN5, SLCO2A1, CXorf36 \n       ENG, PECAM1, CYYR1, MMRN2, NOTCH4, SLC9A3R2, INSR, HYAL2, TM4SF1, ESM1 \nNegative:  COL1A2, COL3A1, COL1A1, DCN, COL6A3, TPM2, C1S, PCOLCE, C1R, COL5A2 \n       TAGLN, LUM, SOD3, COL6A1, RARRES2, BGN, ACTA2, MYL9, AEBP1, SERPINF1 \n       COL6A2, CYGB, MXRA8, RGS5, MFGE8, NDUFA4L2, MEG3, PPP1R14A, SDC2, SERPING1 \nPC_ 5 \nPositive:  RNASE1, UPK2, GDPD3, UBE2C, TMEM97, CNGA1, UPK1A, RAB11FIP1, S100A13, UPK3A \n       BHMT, TNFAIP2, STMN1, CD24, TMPRSS2, PLPP5, SDC4, BIRC5, NQO1, SPRR3 \n       EMX2, KRT20, MKI67, ERBB2, CCNB2, CDK1, HMGB2, PCLAF, MYCL, MESP1 \nNegative:  KRT17, FABP4, SERPINB5, DKK1, PLA2G2A, CLU, CLCA4, CRTAC1, LAMB3, S100A2 \n       AQP3, TSPAN1, IGFBP2, IGFBP5, ERRFI1, IRF6, ANXA1, BTBD16, ANXA10, FHL2 \n       SHH, PERP, FABP5, PRAC1, CYP1B1, FOSL1, HSD17B2, SOX15, SFN, GPR87 \n\n\nCode\ngc()\n\n\n             used    (Mb) gc trigger    (Mb)   max used  (Mb)\nNcells   13337713   712.4   20465354  1093.0   20465354  1093\nVcells 1682605518 12837.3 5535281110 42230.9 5765847106 43990\n\n\nWe can visualize the PCA with DimPlot, coloring by different categorical variables. Here, we see the influence of both the sample (batch) and CD45 positive vs negative (which is correlated to batch but might also contribute to variance).\n\n\nCode\nDimPlot(sc_data, group.by = c(\"sample\", \"CD45\"), reduction = \"pca\") &\n  theme_clean\n\n\n\n\n\n\n\n\n\n\nDimensionality determination\n\nDimensionality of the dataset was then assessed using the JackStraw and ElbowPlot functions.\n\nFrom Seurat documentation, we see that JackStraw is quite computationally intensive:\n\nIn Macosko et al, we implemented a resampling test inspired by the JackStraw procedure. While still available in Seurat (see previous vignette), this is a slow and computationally expensive procedure, and we is no longer routinely used in single cell analysis.\n\nThis is not the most beautiful Elbow plot ever, but the idea is to find the “inflection point” of the plot (I’m estimating at about 10) and go a little bit further into the “stable” area, where adding more dimensions doesn’t add more infromation.\n\n\nCode\nElbowPlot(sc_data, ndims = 30)\n\n\n\n\n\n\n\n\n\nFor methods that require the dimensionality, we’ll set it at 15.\n\n\n\nDoublet detection\nIt’s never a bad idea to add some doublet detection.\nDoublets are UMIs that contained more than one cell and thefore have a mixed profile.\nThis benchmark shows some of the main methods (though new ones may emerge): https://www.sciencedirect.com/science/article/pii/S2405471220304592\nWe’ll use cxds from scdc because it’s fast and reasonably accurate.\nHowever, it uses a SingleCellExperiment standard. Luckily, we can easily convert between SeuratObject and SingleCellExperiment.\n\n\nCode\ncxds_scores &lt;- lapply(SplitObject(sc_data, split.by = \"sample\"), function(samp_sc) {\n  sce &lt;- samp_sc |&gt;\n    as.SingleCellExperiment() |&gt;\n    cxds()\n  return(sce$cxds_score)\n})\ngc()\n\n\n             used    (Mb) gc trigger    (Mb)   max used  (Mb)\nNcells   13355251   713.3   20465354  1093.0   20465354  1093\nVcells 1682217444 12834.4 5535281110 42230.9 5765847106 43990\n\n\nCode\nnames(cxds_scores) &lt;- NULL\nsc_data$cxds_scores &lt;- do.call(c, cxds_scores)[Cells(sc_data)]"
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#clustering",
    "href": "posts/tutorial_seurat_du/intro.html#clustering",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Clustering",
    "text": "Clustering\n\nClusters were calculated […]\n\nBefore clustering, we need to establish a neighborhood graph and compute shared nearest neighbors (SNN). We’ll do this on 15 PCs:\n\n\nCode\nsc_data &lt;- FindNeighbors(sc_data, dims = 1:15)\n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nFrom this, we can use “FindClusters” for Louvain clustering, which uses a rather temperamental “resolution” parameter, very dependent on datasets usually.\nThe largest the “resolution”, the more clusters are obtained.\n\n\nCode\nsc_data &lt;- FindClusters(sc_data, resolution = 0.5, cluster.name = \"unintegrated_clusters\")\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 44699\nNumber of edges: 1534079\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9465\nNumber of communities: 26\nElapsed time: 8 seconds\n\n\nUMAP and t-SNE are dimensionality reductions for visualization. They are very popular and we’ll use them widely. They minimize local distances, often making “neat” looking clusters.\nBe wary of not using the UMAP projection itself as an input for analysis, as they contain lots of data distortions (which is normal of anything that is reducing a space of 3000 features to 2 dimensions)\n\n[…] and data dimensions were reduced using the t-SNE and UMAP methods.\n\n\n\nCode\nsc_data &lt;- RunUMAP(sc_data, dims = 1:15)\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n12:47:24 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n12:47:24 Read 44699 rows and found 15 numeric columns\n\n\n12:47:24 Using Annoy for neighbor search, n_neighbors = 30\n\n\n12:47:24 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n12:47:27 Writing NN index file to temp file /tmp/RtmpiH8I36/file7a2b4fbb2ae2\n12:47:27 Searching Annoy index using 1 thread, search_k = 3000\n12:47:39 Annoy recall = 100%\n12:47:40 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n12:47:42 Initializing from normalized Laplacian + noise (using RSpectra)\n12:47:44 Commencing optimization for 200 epochs, with 1900728 positive edges\n12:47:57 Optimization finished\n\n\nWe can check the state of our Seurat object:\n\n\nCode\nsc_data\n\n\nAn object of class Seurat \n33538 features across 44699 samples within 1 assay \nActive assay: RNA (33538 features, 2000 variable features)\n 21 layers present: counts.1, counts.2, counts.3, counts.4, counts.5, counts.6, counts.7, counts.8, counts.9, counts.10, data.1, data.2, data.3, data.4, data.5, data.6, data.7, data.8, data.9, data.10, scale.data\n 2 dimensional reductions calculated: pca, umap\n\n\nAnd plot the Seurat clusters… only to find we’re definitely clustering per sample.\n\n\nCode\nDimPlot(sc_data, group.by = c(\"unintegrated_clusters\", \"sample\"), reduction = \"umap\", alpha = 0.3) & \n  theme_clean"
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#integration",
    "href": "posts/tutorial_seurat_du/intro.html#integration",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Integration",
    "text": "Integration\nBatch effect is rampant in single-cell RNA-seq and there are lots of integration methods proposed to deal with this. They often return a dimensionality reduction (more precisely, latent space) that minimizes this batch effect.\nThere are 5 methods implemented in Seurat alone. We’ll use Harmony, because it’s fairly fast and effective.\nSee the reference tutorial: https://satijalab.org/seurat/articles/seurat5_integration\n\nBulk cells were merged for the HLA analysis, while CD8 T cells only were merged for the CD8 T cell analysis. CD8 T cells were identified using the FindAllMarkers and the VlnPlot functions.\n\n\n\nCode\nsc_data &lt;- IntegrateLayers(sc_data, \n                           method = HarmonyIntegration,\n                           orig.reduction = \"pca\", \n                           new.reduction = \"harmony\",\n  verbose = FALSE\n)\n\n\nWarning in harmony::HarmonyMatrix(data_mat = Embeddings(object = orig), :\nHarmonyMatrix is deprecated and will be removed in the future from the API in\nthe future\n\n\nWarning: Warning: The parameters do_pca and npcs are deprecated. They will be ignored for this function call and please remove parameters do_pca and npcs and pass to harmony cell_embeddings directly.\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter tau is deprecated. It will be ignored for this function call and please remove parameter tau in future function calls. Advanced users can set value of parameter tau by using parameter .options and function harmony_options().\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter block.size is deprecated. It will be ignored for this function call and please remove parameter block.size in future function calls. Advanced users can set value of parameter block.size by using parameter .options and function harmony_options().\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter max.iter.harmony is replaced with parameter max_iter. It will be ignored for this function call and please use parameter max_iter in future function calls.\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter max.iter.cluster is deprecated. It will be ignored for this function call and please remove parameter max.iter.cluster in future function calls. Advanced users can set value of parameter max.iter.cluster by using parameter .options and function harmony_options().\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter epsilon.cluster is deprecated. It will be ignored for this function call and please remove parameter epsilon.cluster in future function calls. Advanced users can set value of parameter epsilon.cluster by using parameter .options and function harmony_options().\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter epsilon.harmony is deprecated. It will be ignored for this function call and please remove parameter epsilon.harmony in future function calls. If users want to control if harmony would stop early or not, use parameter early_stop. Advanced users can set value of parameter epsilon.harmony by using parameter .options and function harmony_options().\nThis warning is displayed once per session.\n\n\nCode\ngc()\n\n\n             used    (Mb) gc trigger    (Mb)   max used  (Mb)\nNcells   13450619   718.4   20465354  1093.0   20465354  1093\nVcells 1691091272 12902.1 5535281110 42230.9 5765847106 43990\n\n\nWe’ll need re-run clustering algorithm in the Harmony latent space (here, using 30 dimensions)\n\n\nCode\nsc_data &lt;- FindNeighbors(sc_data, reduction = \"harmony\", dims = 1:30)\n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nCode\nsc_data &lt;- FindClusters(sc_data, resolution = 0.5, cluster.name = \"harmony_clusters\")\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 44699\nNumber of edges: 1710955\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9238\nNumber of communities: 18\nElapsed time: 10 seconds\n\n\nWe can also run a UMAP in this latent space:\n\n\nCode\nsc_data &lt;- RunUMAP(sc_data, reduction = \"harmony\", dims = 1:30, reduction.name = \"umap_harmony\")\n\n\n12:49:29 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n12:49:29 Read 44699 rows and found 30 numeric columns\n\n\n12:49:29 Using Annoy for neighbor search, n_neighbors = 30\n\n\n12:49:29 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n12:49:31 Writing NN index file to temp file /tmp/RtmpiH8I36/file7a2b2a001d88\n12:49:31 Searching Annoy index using 1 thread, search_k = 3000\n12:49:44 Annoy recall = 100%\n12:49:44 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n12:49:46 Initializing from normalized Laplacian + noise (using RSpectra)\n12:49:48 Commencing optimization for 200 epochs, with 2061946 positive edges\n12:50:03 Optimization finished\n\n\n\n\nCode\nDimPlot(sc_data, \n        group.by = c(\"unintegrated_clusters\", \"harmony_clusters\", \"sample\"), \n        reduction = \"umap_harmony\",\n        alpha = 0.2,\n        ncol = 2) & \n  theme_clean\n\n\n\n\n\n\n\n\n\n\nCheck biases\nWe can check back on our features that could be markers of bias in a cluster, and check back in with our doublet scores:\n\n\nCode\nsc_data$cxds_scores[1:5]\n\n\nAAACCTGAGGCCCTCA-1_1 AAACCTGAGTTCGCGC-1_1 AAACCTGCACTGTTAG-1_1 \n           266320.09             29805.91            219085.93 \nAAACCTGCAGACGCTC-1_1 AAACCTGGTACAGCAG-1_1 \n           100458.58            193619.85 \n\n\n\n\nCode\nRidgePlot(sc_data, \n        features = c(\"nCount_RNA\", \"nFeature_RNA\", \n                     \"percent.mt\",\"cxds_scores\"), \n        ncol = 2) &\n  guides(fill = \"none\") &\n  theme_clean \n\n\nPicking joint bandwidth of 569\n\n\nPicking joint bandwidth of 123\n\n\nPicking joint bandwidth of 0.469\n\n\nPicking joint bandwidth of 6840\n\n\n\n\n\n\n\n\n\nWe can see, for example, that cluster 17 seems to be enriched in doublets.\nTo compare the co-occurence of two categorical variables, we can do a heatmap:\n\n\nCode\ntable(sc_data$harmony_clusters, sc_data$sample) |&gt;\n  pheatmap(scale = \"row\")\n\n\n\n\n\n\n\n\n\nFrom this, we can exclude cluster 17:\n\n\nCode\nsc_data &lt;- subset(sc_data, subset = harmony_clusters != 17)"
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#annotation",
    "href": "posts/tutorial_seurat_du/intro.html#annotation",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Annotation",
    "text": "Annotation\n\nDifferential Expression\nDifferential expression analysis will by default run on the “identity” feature, which we make sure to set as “harmony_clusters” at this point:\n\n\nCode\nIdents(sc_data) &lt;- sc_data$harmony_clusters\nIdents(sc_data)[1:5]\n\n\nAAACCTGAGGCCCTCA-1_1 AAACCTGAGTTCGCGC-1_1 AAACCTGCACTGTTAG-1_1 \n                   2                    6                    1 \nAAACCTGCAGACGCTC-1_1 AAACCTGGTACAGCAG-1_1 \n                   3                    1 \nLevels: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\n\nFor differential analysis to use all layers at the same time, we need to join them before finding markers (each clusters vs all others):\n\n\nCode\nsc_data &lt;- JoinLayers(sc_data)\nmarkers &lt;- FindAllMarkers(sc_data)\n\n\nCalculating cluster 0\n\n\nCalculating cluster 1\n\n\nCalculating cluster 2\n\n\nCalculating cluster 3\n\n\nCalculating cluster 4\n\n\nCalculating cluster 5\n\n\nCalculating cluster 6\n\n\nCalculating cluster 7\n\n\nCalculating cluster 8\n\n\nCalculating cluster 9\n\n\nCalculating cluster 10\n\n\nCalculating cluster 11\n\n\nCalculating cluster 12\n\n\nCalculating cluster 13\n\n\nCalculating cluster 14\n\n\nCalculating cluster 15\n\n\nCalculating cluster 16\n\n\nFor annotation, we can now use this table:\n\n\nCode\nmarkers |&gt; head()\n\n\n     p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene\nIL7R     0   2.929902 0.634 0.158         0       0 IL7R\nCD3D     0   1.512433 0.750 0.281         0       0 CD3D\nIL32     0   1.225477 0.865 0.404         0       0 IL32\nTRAC     0   1.525893 0.722 0.273         0       0 TRAC\nLTB      0   2.055308 0.713 0.273         0       0  LTB\nCD2      0   1.805078 0.660 0.230         0       0  CD2\n\n\nAnd visualize either top markers or any chosen features in many different ways:\n\n\nCode\ntop_markers &lt;- markers |&gt;\n    group_by(cluster) |&gt;\n    dplyr::filter(avg_log2FC &gt; 1) |&gt;\n    arrange(p_val_adj) |&gt;\n    slice_head(n = 5) |&gt;\n    ungroup()\ntop5 &lt;- unique(top_markers$gene)\n\n\n\nHeatmap\nThe heatmap takes a while to run, but provides a comprehensive view of a marker expression over the cells:\n\n\nCode\nDoHeatmap(sc_data, features = top5, raster = TRUE) +\n  scale_fill_viridis_c()\n\n\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\nDot plot\nThe dotplot summarizes the information into the heatmap and gives the same importance to all clusters, independent of size:\n\n\nCode\nDotPlot(sc_data, features = top5, cluster.idents = TRUE) + theme_clean\n\n\n\n\n\n\n\n\n\n\n\nFeaturePlot\nFeaturePlot is the same as DimPlot, but using one or many continuous values instead:\n\n\nCode\nFeaturePlot(sc_data, reduction = \"umap_harmony\",\n            features = c(\"CD3D\", \"MS4A1\",\n                         \"CD14\", \"PECAM1\",\n                         \"KRT20\", \"KRT5\")) &\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\n\nReference-based\nThere are an infinity of methods for cell type annotation. I’ve found that using a good reference is more important than the method for annotation.\nWe’ll show reference-based annotation using SingleR, mostly because it’s easy to use but also well performing.\n\n“Built-in” references\nEvery automatic annotation method uses a reference. celldex provides an easy way to access some annotation sources, notably the Human Primary Cell Atlas, which we will use in this example.\n\n\nCode\nlibrary(celldex)\nsurveyReferences() |&gt;  as_tibble()\n\n\n# A tibble: 7 × 10\n  name         version path  title description taxonomy_id genome samples labels\n  &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;list&gt;      &lt;list&gt;   &lt;int&gt; &lt;list&gt;\n1 dice         2024-0… &lt;NA&gt;  Huma… Human bulk… &lt;list [1]&gt;  &lt;list&gt;    1561 &lt;list&gt;\n2 blueprint_e… 2024-0… &lt;NA&gt;  Huma… Human bulk… &lt;list [1]&gt;  &lt;list&gt;     259 &lt;list&gt;\n3 immgen       2024-0… &lt;NA&gt;  Mous… Mouse micr… &lt;list [1]&gt;  &lt;list&gt;     830 &lt;list&gt;\n4 mouse_rnaseq 2024-0… &lt;NA&gt;  Bulk… Bulk RNA-s… &lt;list [1]&gt;  &lt;list&gt;     358 &lt;list&gt;\n5 hpca         2024-0… &lt;NA&gt;  Micr… Microarray… &lt;list [1]&gt;  &lt;list&gt;     713 &lt;list&gt;\n6 novershtern… 2024-0… &lt;NA&gt;  Bulk… Bulk micro… &lt;list [1]&gt;  &lt;list&gt;     211 &lt;list&gt;\n7 monaco_immu… 2024-0… &lt;NA&gt;  Huma… Human bulk… &lt;list [1]&gt;  &lt;list&gt;     114 &lt;list&gt;\n# ℹ 1 more variable: sources &lt;list&gt;\n\n\n\n\nCode\nhpca_se &lt;- celldex::HumanPrimaryCellAtlasData()\nhpca_se\n\n\nclass: SummarizedExperiment \ndim: 19363 713 \nmetadata(0):\nassays(1): logcounts\nrownames(19363): A1BG A1BG-AS1 ... ZZEF1 ZZZ3\nrowData names(0):\ncolnames(713): GSM112490 GSM112491 ... GSM92233 GSM92234\ncolData names(3): label.main label.fine label.ont\n\n\nIt’s given as a SummarizedExperiment of purified bulk tumors.=, annotated as follows:\n\n\nCode\nunique(hpca_se$label.main)\n\n\n [1] \"DC\"                   \"Smooth_muscle_cells\"  \"Epithelial_cells\"    \n [4] \"B_cell\"               \"Neutrophils\"          \"T_cells\"             \n [7] \"Monocyte\"             \"Erythroblast\"         \"BM & Prog.\"          \n[10] \"Endothelial_cells\"    \"Gametocytes\"          \"Neurons\"             \n[13] \"Keratinocytes\"        \"HSC_-G-CSF\"           \"Macrophage\"          \n[16] \"NK_cell\"              \"Embryonic_stem_cells\" \"Tissue_stem_cells\"   \n[19] \"Chondrocytes\"         \"Osteoblasts\"          \"BM\"                  \n[22] \"Platelets\"            \"Fibroblasts\"          \"iPS_cells\"           \n[25] \"Hepatocytes\"          \"MSC\"                  \"Neuroepithelial_cell\"\n[28] \"Astrocyte\"            \"HSC_CD34+\"            \"CMP\"                 \n[31] \"GMP\"                  \"MEP\"                  \"Myelocyte\"           \n[34] \"Pre-B_cell_CD34-\"     \"Pro-B_cell_CD34+\"     \"Pro-Myelocyte\"       \n\n\nThere’s also a finer annotation, which we won’t use:\n\n\nCode\nunique(hpca_se$label.fine) |&gt; head(n = 20)\n\n\n [1] \"DC:monocyte-derived:immature\"        \"DC:monocyte-derived:Galectin-1\"     \n [3] \"DC:monocyte-derived:LPS\"             \"DC:monocyte-derived\"                \n [5] \"Smooth_muscle_cells:bronchial:vit_D\" \"Smooth_muscle_cells:bronchial\"      \n [7] \"Epithelial_cells:bronchial\"          \"B_cell\"                             \n [9] \"Neutrophil\"                          \"T_cell:CD8+_Central_memory\"         \n[11] \"T_cell:CD8+\"                         \"T_cell:CD4+\"                        \n[13] \"T_cell:CD8+_effector_memory_RA\"      \"T_cell:CD8+_effector_memory\"        \n[15] \"T_cell:CD8+_naive\"                   \"Monocyte\"                           \n[17] \"Erythroblast\"                        \"BM\"                                 \n[19] \"DC:monocyte-derived:rosiglitazone\"   \"DC:monocyte-derived:AM580\"          \n\n\nSingleR is really simple to use, we just need to provide an expression matrix and reference as SummarizedExperiment:\n\n\nCode\nlibrary(SingleR)\npred_hpca &lt;- SingleR(test = GetAssayData(sc_data), ref = hpca_se, assay.type.test=1,\n    labels = hpca_se$label.main)\npred_hpca\n\n\nDataFrame with 44535 rows and 4 columns\n                                                scores              labels\n                                              &lt;matrix&gt;         &lt;character&gt;\nAAACCTGAGGCCCTCA-1_1   0.2029037:0.213122:0.201966:...    Epithelial_cells\nAAACCTGAGTTCGCGC-1_1   0.0681688:0.198615:0.175877:...              B_cell\nAAACCTGCACTGTTAG-1_1   0.0876658:0.201213:0.204570:...             T_cells\nAAACCTGCAGACGCTC-1_1   0.1877214:0.195236:0.193748:...    Epithelial_cells\nAAACCTGGTACAGCAG-1_1   0.0911602:0.192878:0.188423:...             T_cells\n...                                                ...                 ...\nTTTGTCAGTAAGTAGT-1_10 0.1291041:0.126240:0.0979679:...   Endothelial_cells\nTTTGTCAGTCCTCCAT-1_10 0.2087580:0.136874:0.1276952:... Smooth_muscle_cells\nTTTGTCAGTCTAGTCA-1_10 0.1394180:0.249968:0.2645048:...            Monocyte\nTTTGTCAGTGCTGTAT-1_10 0.2323622:0.210428:0.1944528:...   Endothelial_cells\nTTTGTCATCTAGCACA-1_10 0.0968535:0.202014:0.1887533:...             NK_cell\n                      delta.next       pruned.labels\n                       &lt;numeric&gt;         &lt;character&gt;\nAAACCTGAGGCCCTCA-1_1   0.0539724    Epithelial_cells\nAAACCTGAGTTCGCGC-1_1   0.0693563              B_cell\nAAACCTGCACTGTTAG-1_1   0.1751957             T_cells\nAAACCTGCAGACGCTC-1_1   0.5717106    Epithelial_cells\nAAACCTGGTACAGCAG-1_1   0.0322466             T_cells\n...                          ...                 ...\nTTTGTCAGTAAGTAGT-1_10 0.05911158   Endothelial_cells\nTTTGTCAGTCCTCCAT-1_10 0.00671502 Smooth_muscle_cells\nTTTGTCAGTCTAGTCA-1_10 0.02419472            Monocyte\nTTTGTCAGTGCTGTAT-1_10 0.06293215   Endothelial_cells\nTTTGTCATCTAGCACA-1_10 0.09986082             NK_cell\n\n\nOnce we have the predictions, I add it to the Seurat object:\n\n\nCode\nsc_data@tools[[\"SingleR\"]] &lt;- pred_hpca |&gt; as.data.frame()\nsc_data$singleR_pred &lt;- pred_hpca$pruned.labels\n\n\n\nHarmonizing automatic predictions\nWe can check the prediction results and “harmonize” them by cluster, i.e. take the cluster-level mode of the annotation:\n\n\nCode\nharmony_singler &lt;- table(sc_data$singleR_pred, factor(sc_data$harmony_clusters))\npheatmap::pheatmap(harmony_singler, scale = \"column\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nharmony_map1 &lt;- apply(harmony_singler, 2, function(x) names(which.max(x)))\nharmony_map1 &lt;- structure(names(harmony_map1), names = harmony_map1)\nharmony_map1\n\n\n          T_cells           T_cells  Epithelial_cells  Epithelial_cells \n              \"0\"               \"1\"               \"2\"               \"3\" \n         Monocyte        Macrophage            B_cell Tissue_stem_cells \n              \"4\"               \"5\"               \"6\"               \"7\" \n          T_cells            B_cell  Epithelial_cells  Epithelial_cells \n              \"8\"               \"9\"              \"10\"              \"11\" \nEndothelial_cells          Monocyte               CMP  Pre-B_cell_CD34- \n             \"12\"              \"13\"              \"14\"              \"15\" \n               DC \n             \"16\" \n\n\n\n\nCode\nsc_data$singleR_clean &lt;- fct_recode(sc_data$harmony_clusters, !!! harmony_map1)\n\n\nIf we plot, we can see the difference between the “pred” and “clean”:\n\n\nCode\nDimPlot(sc_data, \n        group.by = c(\"harmony_clusters\", \"singleR_pred\", \n                     \"singleR_clean\", \"sample\"), \n        reduction = \"umap_harmony\",\n        ncol = 2,\n        alpha = 0.2) & \n  theme_clean &\n  scale_color_igv()\n\n\nWarning: Removed 67 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\nSingle-cell\nMost methods will work best with a relevant single-cell reference.\nHere is a not-so-recent but independent benchmark: https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1795-z\nIt can be interesting to try to use this tutorial to annotate a query dataset based on a reference atlas: https://satijalab.org/seurat/articles/integration_mapping"
  },
  {
    "objectID": "posts/tutorial_seurat_du/intro.html#extras",
    "href": "posts/tutorial_seurat_du/intro.html#extras",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Extras",
    "text": "Extras\n\nSub-cluster\nIn their manuscript, Salomé et al selected the T cells and subclustered them. This is a common strategy when there is a main population of interest. In fact, most of their analysis concentrated on the CD8 T cells.\nAt this point, we could take our annotated data, subset the T cells and re-run the pipeline to find new relevant subgroups.\n\n\nTrajectory analysis\nTrajectory analysis is used to reconstruct and visualize the dynamic processes of cellular development, differentiation, and state transitions. It infers the order of cells in a particular trajectory, allows us to calculate continuous “pseudotimes”.\nIt can be used to map out potential lineage relationships, identify intermediate cell states, and elucidate the pathways underlying tissue development, immune responses, or disease progression, for example.\nIn Figure 4, Salomé et al used this to show a subset of differentiated PD-1+ TRM CD8+ T Cells that retain independent function.\n\nA not so new but very comprehensive benchmark of trajectory inference by Saelens et al is a great jumping point: https://www.nature.com/articles/s41587-019-0071-9\nAccompanied by the superb dynverse wrappers, which provide all methods in the benchmark, as well as guidance on what to choose: https://dynverse.org/\n\n\nCell cycle\nThere are many methods to infer cell cycle stage and score cell cycle in Seurat, but it also has a built in one that works quite decently:\n\n\nCode\nsc_data &lt;- CellCycleScoring(sc_data, \n                 s.features = cc.genes.updated.2019$s.genes, \n                 g2m.features = cc.genes.updated.2019$g2m.genes)\n\n\n\n\nCode\nFeaturePlot(sc_data, \n        features = c(\"S.Score\", \"G2M.Score\"),\n        reduction = \"umap_harmony\",\n        ncol = 2,\n        alpha = 0.2) & \n  theme_clean\n\n\n\n\n\n\n\n\n\nWe can see very little cycling except in one “epithelial” (tumor) area we previously annotated.\n\n\nRNA velocity\nRNA velocity is a computation method that attempts to predict the future transcriptional state of individual cells. It distinguishes between unspliced (pre-mRNA) and spliced (mature mRNA) transcripts within each cell, and therefore necessitates a special input in which these reads have been separated. This differentiation allows the estimation of the rate at which genes are being transcribed and processed, providing insights into the “direction” and “speed” of cellular state changes.\nThe primary goal of RNA velocity analysis is to elucidate the trajectories of cellular differentiation, activation, and other dynamic processes, thereby offering a deeper understanding of cellular development and lineage relationships. By forecasting how cells are likely to evolve, it can help in identifying transient cell states, and uncovering mechanisms underlying tissue development, regeneration, and disease progression.\nIt can be used together with traditional trajectory analysis.\nMost RNA velocity tools work in Python, the two most well-known being velocyto and scVelo. Both have tutorials showing how to use reticulate to run their workflows in R.\n\n\nPathway enrichment\nPathway enrichment aims to identify biological pathways, processes, or functional categories that are significantly overrepresented within a set of genes of interest, such as those differentially expressed between distinct cell populations or states.\nThis analysis typically involves mapping the selected genes to curated pathway databases like Gene Ontology, KEGG, or Reactome and applying statistical methods to assess the significance of their enrichment.\nThere are many methods to do this, but a easy to use is decoupleR, in which AUCell is implemented, which is a well-performing scoring method: https://www.bioconductor.org/packages/release/bioc/vignettes/decoupleR/inst/doc/decoupleR.html\n\n\nGene regulatory network\nGene regulatory network (GRN) analysis seeks to identify key transcription factors, regulatory motifs, and signaling pathways that drive cell states, differentiation, and responses to environmental stimuli. The ultimate goal of GRN analysis is to map out the regulatory architecture that underpins cellular heterogeneity, enabling \\ to pinpoint master regulators and understand the molecular mechanisms underlying various biological processes and disease states.\nFrom an algorithmic point of view, this involves inferring relationships such as gene co-expression, regulatory influences, and causal interactions.\nSCENIC is the most popular method to do this, with the Python implementation being much more performant (https://github.com/aertslab/pySCENIC). The protocol is probably the best way to run this type of analysis currently: https://github.com/aertslab/SCENICprotocol\n\n\nCNV analysis\nCopy Number Variation (CNV) analysis is a computational approach used to infer genomic copy number alterations from transcriptomic data. It leverages the variability in gene expression levels across the genome to detect gains or losses of genomic regions.\nThis method is particularly valuable in studies of cancer and other genetic disorders, where CNVs play a crucial role in disease progression and heterogeneity.\nThe most well-known tool used for this analysis is inferCNV, which can be extremely slow and doesn’t perform very well with cells with low-read count. This is why we implemented FastCNV, available to install for R on Github: https://github.com/must-bioinfo/fastCNVdata\n\n\nLigand-receptor analysis\nLigand-receptor analysis is a computational strategy to infer cell-cell communication by identifying interactions between signaling molecules (ligands) and their corresponding receptors expressed on different cell types or states.\nThis analysis involves systematically pairing ligands expressed by one or more cell populations with receptors expressed by neighboring or interacting cells, thereby predicting potential signaling pathways that facilitate intercellular communication.\nWell known tools are CellPhoneDB and CellChat, but LIANA+ provides wrappers and an all-in-one framework for this kind of analysis: https://liana-py.readthedocs.io/en/latest/\nNotably, this analysis can be much more powerful in spatially-resolved data.\n\n\nObject conversion\nFormat conversion is often necessary when working with single-cell RNA-seq to use tools available for different objects.\nThis can be easy between SingleCellExperiment and SeuratObject, as we used it in this tutorial with as.SingleCellExperiment and as.Seurat.\nHowever, these functions sometimes don’t work and the Seurat solution for h5 objects, SeuratDisk, fails its own tutorial. sceasy (https://github.com/cellgeni/sceasy) was made to resolve these conversion problems."
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html",
    "href": "posts/tutorial_seurat_du/index.html",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "",
    "text": "Download this notebook: https://raw.githubusercontent.com/csgroen/teaching/refs/heads/main/20250214_Tutorial_DU_Seurat.qmd"
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#pre-requisites",
    "href": "posts/tutorial_seurat_du/index.html#pre-requisites",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Pre-requisites",
    "text": "Pre-requisites\nFor the best understanding of this tutorial, please make sure you have at least an intermediate understanding of R. Here are some recommended resources to learn the basics and necessary intermediate concepts:\n\nswirl: https://swirlstats.com/students.html\n\nSpecifically courses R Programming, Getting and Cleaning Data and Exploratory Data Analysis may provide a good jump start.\n\nHands On Programming with R: https://rstudio-education.github.io/hopr/\n\nThe very basics of R programming as also explained in this thorough book from the Posit team (that builds RStudio).\n\nR for Data Science: https://r4ds.hadley.nz/\n\nThis goes further than we need, but a base for most of the programming questions a data analyst working in R could have to start with."
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#resources",
    "href": "posts/tutorial_seurat_du/index.html#resources",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Resources",
    "text": "Resources\nSeurat has many very useful tutorials for all of its features. Elements of this case study were taken from the following:\n\nSeurat - Guided Clustering Tutorial https://satijalab.org/seurat/archive/v3.0/pbmc3k_tutorial.html\nIntroduction to scRNA-seq integration: https://satijalab.org/seurat/articles/integration_introduction\nMapping and annotating query datasets: https://satijalab.org/seurat/articles/integration_mapping"
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#install-packages",
    "href": "posts/tutorial_seurat_du/index.html#install-packages",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Install packages",
    "text": "Install packages\nTo ensure we have all installed libraries, we’ll use R package “pacman”, which allows us to check if packages are not installed and load them. This is not a replacement for more comprehensive version control (e.g. using renv), but it’s simple to install and very lightweight.\n\n\nCode\nif(! \"pacman\" %in% installed.packages()) install.packages(\"pacman\")\npacman::p_load(\"Seurat\", \"tidyverse\", \"R.utils\", \"ggpubr\", \"patchwork\", \n               \"celldex\", \"SingleR\", \"scRNAseq\", \"pheatmap\",\n               \"ggsci\", \"scds\")\n\n\nI’m personally not a big fan of the standard look of Seurat plots, so I’ll apply this ggplot2 theme to (almost) all Seurat plots we generate:\n\n\nCode\ntheme_clean &lt;-\n  theme_linedraw() +\n  theme(panel.grid = element_blank(),\n        panel.border = element_blank(),\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n\n\n\nNote: Seurat plots are ggplot-based and therefore can be “added to” in a grammar-of-graphics manner. Plots for multiple features are patchworks, which use a slightly different syntax to add to (this is why sometimes you’ll see & instead of + being used)."
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#download-data",
    "href": "posts/tutorial_seurat_du/index.html#download-data",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Download data",
    "text": "Download data\nOur dataset comes from Salomé et al (2022), “NKG2A and HLA-E define an alternative immune checkpoint axis in bladder cancer”. This single-cell data is a bit particular: they have FACS-sorted their cells into CD45+ and CD45-, notably to enrich their dataset in hematopoetic cells.\nWe’ll download the data from the link provided in the article:\n\n\nCode\ndir.create(\"data\")\ndownload.file(\"https://prod-dcd-datasets-cache-zipfiles.s3.eu-west-1.amazonaws.com/7yb7s9769c-1.zip\", 'data/Salome_2022.zip')\nunzip('data/Salome_2022.zip', exdir = \"data\")"
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#read-10x-data",
    "href": "posts/tutorial_seurat_du/index.html#read-10x-data",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Read 10X data",
    "text": "Read 10X data\n\n\nCode\nref_dir &lt;- \"data/NKG2A and HLA-E define an alternative immune checkpoint axis in bladder cancer/\"\nlist.files(ref_dir)\n\n\n [1] \"385_Patient49_CD45pos\" \"394_Patient50_CD45pos\" \"397_Patient51_CD45pos\"\n [4] \"421_Patient52_CD45pos\" \"434_Patient53_CD45pos\" \"435_Patient54_CD45pos\"\n [7] \"453_Patient01_CD45pos\" \"454_Patient01_CD45neg\" \"456_Patient02_CD45pos\"\n[10] \"457_Patient02_CD45neg\" \"584_Patient03_bulk\"    \"595_Patient04_bulk\"   \n[13] \"613_Patient55_bulk\"    \"651_Patient05_bulk\"    \"656_Patient06_bulk\"   \n[16] \"663_Patient07_bulk\"    \"695_Patient08_bulk\"   \n\n\nWe can see the data is distributed as one folder per dataset, and includes the bulk data, which we’re not going to use. For this reason, I will filter out the “bulk” folders and to get my vector of sc_dts (single-cell datasets).\n\n\nCode\nsc_dts &lt;- ref_dir |&gt; list.files() |&gt; str_subset(\"bulk\", negate = TRUE)\nsc_dts\n\n\n [1] \"385_Patient49_CD45pos\" \"394_Patient50_CD45pos\" \"397_Patient51_CD45pos\"\n [4] \"421_Patient52_CD45pos\" \"434_Patient53_CD45pos\" \"435_Patient54_CD45pos\"\n [7] \"453_Patient01_CD45pos\" \"454_Patient01_CD45neg\" \"456_Patient02_CD45pos\"\n[10] \"457_Patient02_CD45neg\"\n\n\n\nSyntax note: ref_dir |&gt; list.files() |&gt; str_subset(\"bulk\", negate = TRUE) is equivalent to str_subset(list.files(ref_dir), \"bulk\", negate = TRUE). The |&gt; was first introduced as %&gt;% from R package magrittr and officially incorporated into base R&gt;=4.0. It’s purpose is to increase code legibility through “chaining” commands instead of “nesting” them. If you would like to learn more, you can check the help file ? |&gt;\n\nWe can check inside each folder:\n\n\nCode\nref_dir |&gt; filePath(sc_dts[1]) |&gt; list.files()\n\n\n[1] \"barcodes.tsv.gz\" \"features.tsv.gz\" \"matrix.mtx.gz\"  \n\n\nThis is a common export of single-cell data and can be read directly into Seurat using function Read10X.\nThis snippet will read all of our samples at once:\n\n\nCode\nread_exp_sample &lt;- function(sc_file) {\n  message('Reading file: ', sc_file)\n  so &lt;- ref_dir |&gt; filePath(sc_file) |&gt; Read10X()\n  so &lt;- CreateSeuratObject(so, project = \"BLCA_NKG2A\")\n  so[[\"sample\"]] &lt;- str_remove(sc_file, \"^.{4}\")\n  so[[\"patient\"]] &lt;- str_extract(sc_file, \"Patient..\")\n  so[[\"CD45\"]] &lt;- str_extract(sc_file, \"(?&lt;=CD45).*\")\n  return(so)\n}\n\nsc_data &lt;- lapply(sc_dts, read_exp_sample)\n\n\nReading file: 385_Patient49_CD45pos\n\n\nReading file: 394_Patient50_CD45pos\n\n\nReading file: 397_Patient51_CD45pos\n\n\nReading file: 421_Patient52_CD45pos\n\n\nReading file: 434_Patient53_CD45pos\n\n\nReading file: 435_Patient54_CD45pos\n\n\nReading file: 453_Patient01_CD45pos\n\n\nReading file: 454_Patient01_CD45neg\n\n\nReading file: 456_Patient02_CD45pos\n\n\nReading file: 457_Patient02_CD45neg\n\n\nCode\nnames(sc_data) &lt;- sc_dts\n\n\n\nMerge samples\nThe script we ran generated 10 Seurat objects, which we will merge into one for further analysis. Each count matrix, at first, will be stored as a Layer in our Seurat object.\n\n\nCode\nsc_data &lt;- merge(sc_data[[1]], sc_data[2:length(sc_data)])\n\n\nWarning: Some cell names are duplicated across objects provided. Renaming to\nenforce unique cell names."
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#seurat-syntax-basics-for-object-accession",
    "href": "posts/tutorial_seurat_du/index.html#seurat-syntax-basics-for-object-accession",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Seurat syntax basics for object accession",
    "text": "Seurat syntax basics for object accession\nHere are some “essential commands” for accession of information inside the Seurat object: https://satijalab.org/seurat/articles/essential_commands.html.\nThe document also outlines the “basic pipeline”.\nTo see some general info about the object, we can just print it:\n\n\nCode\nsc_data\n\n\nAn object of class Seurat \n33538 features across 50940 samples within 1 assay \nActive assay: RNA (33538 features, 0 variable features)\n 10 layers present: counts.1, counts.2, counts.3, counts.4, counts.5, counts.6, counts.7, counts.8, counts.9, counts.10\n\n\nNote the layers, for the different samples. We can also see what analyses have been run in this object (none yet).\n\nCell metadata\n[[]] allows us to access the cell metadata in a concise manner:\n\n\nCode\nsc_data[[]] |&gt; head()\n\n\n                     orig.ident nCount_RNA nFeature_RNA            sample\nAAACCTGAGGCCCTCA-1_1 BLCA_NKG2A       4917         1671 Patient49_CD45pos\nAAACCTGAGTTCGCGC-1_1 BLCA_NKG2A        891          369 Patient49_CD45pos\nAAACCTGCACTGTTAG-1_1 BLCA_NKG2A       1121          606 Patient49_CD45pos\nAAACCTGCAGACGCTC-1_1 BLCA_NKG2A       3877         1484 Patient49_CD45pos\nAAACCTGGTACAGCAG-1_1 BLCA_NKG2A       1393          552 Patient49_CD45pos\nAAACCTGGTCACACGC-1_1 BLCA_NKG2A       1491          709 Patient49_CD45pos\n                       patient CD45\nAAACCTGAGGCCCTCA-1_1 Patient49  pos\nAAACCTGAGTTCGCGC-1_1 Patient49  pos\nAAACCTGCACTGTTAG-1_1 Patient49  pos\nAAACCTGCAGACGCTC-1_1 Patient49  pos\nAAACCTGGTACAGCAG-1_1 Patient49  pos\nAAACCTGGTCACACGC-1_1 Patient49  pos\n\n\n\n\nAssay matrix (e.g. counts)\nTo get matrices from the Seurat objects, there are many “official” ways, but one of these two, which have exactly the same output, should work well:\n\n\nCode\nGetAssayData(sc_data, layer = \"counts.1\")[1:5,1:5]\n\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n            AAACCTGAGGCCCTCA-1_1 AAACCTGAGTTCGCGC-1_1 AAACCTGCACTGTTAG-1_1\nMIR1302-2HG                    .                    .                    .\nFAM138A                        .                    .                    .\nOR4F5                          .                    .                    .\nAL627309.1                     .                    .                    .\nAL627309.3                     .                    .                    .\n            AAACCTGCAGACGCTC-1_1 AAACCTGGTACAGCAG-1_1\nMIR1302-2HG                    .                    .\nFAM138A                        .                    .\nOR4F5                          .                    .\nAL627309.1                     .                    .\nAL627309.3                     .                    .\n\n\nCode\nsc_data[[\"RNA\"]]$counts.1[1:5,1:5]\n\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n            AAACCTGAGGCCCTCA-1_1 AAACCTGAGTTCGCGC-1_1 AAACCTGCACTGTTAG-1_1\nMIR1302-2HG                    .                    .                    .\nFAM138A                        .                    .                    .\nOR4F5                          .                    .                    .\nAL627309.1                     .                    .                    .\nAL627309.3                     .                    .                    .\n            AAACCTGCAGACGCTC-1_1 AAACCTGGTACAGCAG-1_1\nMIR1302-2HG                    .                    .\nFAM138A                        .                    .\nOR4F5                          .                    .\nAL627309.1                     .                    .\nAL627309.3                     .                    .\n\n\n\n\nUMI ids\nTo get the “ids” of the cells, we can simply call:\n\n\nCode\nCells(sc_data)[1:5]\n\n\n[1] \"AAACCTGAGGCCCTCA-1_1\" \"AAACCTGAGTTCGCGC-1_1\" \"AAACCTGCACTGTTAG-1_1\"\n[4] \"AAACCTGCAGACGCTC-1_1\" \"AAACCTGGTACAGCAG-1_1\"\n\n\n\n\nFeatures\nFor a single-cell RNA-seq object, we can see the genes (features) like so:\n\n\nCode\nFeatures(sc_data)[1:5]\n\n\n[1] \"MIR1302-2HG\" \"FAM138A\"     \"OR4F5\"       \"AL627309.1\"  \"AL627309.3\""
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#pre-processing-workflow",
    "href": "posts/tutorial_seurat_du/index.html#pre-processing-workflow",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Pre-processing workflow",
    "text": "Pre-processing workflow\nThere are very standard steps for pre-processing, but that require some level of decision on the part of the user. The basic tutorial of Seurat, on PBMCs, covers this in detail: https://satijalab.org/seurat/articles/pbmc3k_tutorial\n\nQC and selecting cells for further analysis\nThis command will figure out the percentage of reads of mitchondrial RNA:\n\n\nCode\nsc_data[[\"percent.mt\"]] &lt;- PercentageFeatureSet(sc_data, pattern = \"^MT-\")\n\n\nThere are three major pieces of information we’d like to check to make filtering decisions: number of expressed features, number of reads and the percentage of mitochondrial RNA. Here, I plot per sample:\n\n\nCode\n(VlnPlot(sc_data, \n        features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), \n        group.by = \"sample\",\n        alpha = 0.3, \n        ncol = 3) &\n  theme_clean) +\n  plot_layout(guides = \"collect\")\n\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\n\nWe can also plot this for a particular known variable. For example, here I show for whether the cells were FACS-sorted as CD45 positive or negative:\n\n\nCode\n(VlnPlot(sc_data, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), \n         alpha = 0.3,\n         group.by = \"CD45\", ncol = 3) &\n  stat_compare_means() &\n  theme_clean) +\n  plot_layout(guides = \"collect\") +\n  plot_annotation(title = \"CD45\")\n\n\nWarning: Default search for \"data\" layer in \"RNA\" assay yielded no results;\nutilizing \"counts\" layer instead.\n\n\n\n\n\n\n\n\n\n\n\nFiltering and Normalization\nWe’ll reproduce the filtering and normalization steps proposed by the paper as closely as possible:\n\nFor each sample, cells were first selected as expressing less than 16–20% mitochondrial genes and displaying a minimum of 200–300 and a maximum of 2500–3500 features.\n\nAs we’re standardizing pre-processing for all samples, we’ll take the least stringent:\n\n\nCode\nsc_data &lt;- subset(sc_data, subset = nFeature_RNA &gt; 200 & nFeature_RNA &lt; 3500 & percent.mt &lt; 20)\n\n\n\nData were then log-normalized using a scale factor of 10,000.\n\n\n\nCode\nsc_data &lt;- NormalizeData(sc_data, normalization.method = \"LogNormalize\", scale.factor = 1e4)\n\n\nNormalizing layer: counts.1\n\n\nNormalizing layer: counts.2\n\n\nNormalizing layer: counts.3\n\n\nNormalizing layer: counts.4\n\n\nNormalizing layer: counts.5\n\n\nNormalizing layer: counts.6\n\n\nNormalizing layer: counts.7\n\n\nNormalizing layer: counts.8\n\n\nNormalizing layer: counts.9\n\n\nNormalizing layer: counts.10\n\n\n\n\nFeature selection and PCA\n\nThe 2,000 most variable features were then identified, data were scaled based on all the features […]\n\n\n\nCode\nsc_data &lt;- FindVariableFeatures(sc_data, nfeatures = 2000)\n\n\nFinding variable features for layer counts.1\n\n\nFinding variable features for layer counts.2\n\n\nFinding variable features for layer counts.3\n\n\nFinding variable features for layer counts.4\n\n\nFinding variable features for layer counts.5\n\n\nFinding variable features for layer counts.6\n\n\nFinding variable features for layer counts.7\n\n\nFinding variable features for layer counts.8\n\n\nFinding variable features for layer counts.9\n\n\nFinding variable features for layer counts.10\n\n\nCode\nsc_data &lt;- ScaleData(sc_data, features = rownames(sc_data))\n\n\nCentering and scaling data matrix\n\n\n\n[…] and principal component analysis was performed.\n\n\n\nCode\nsc_data &lt;- RunPCA(sc_data)\n\n\nPC_ 1 \nPositive:  S100P, SPINK1, KRT18, ADIRF, PSCA, KRT8, KRT19, MGST1, GDF15, KLF5 \n       CD24, HPGD, DHRS2, HES1, VSIG2, SDC4, SMIM22, C19orf33, SLPI, S100A6 \n       AGR2, SPINT2, TNFAIP2, GPRC5A, TSPAN6, S100A13, CLDN7, CD9, EFNA1, WFDC2 \nNegative:  CD52, IGKC, LAPTM5, RGS1, S100A4, IGLC2, IL32, CD3D, CD74, IGHA1 \n       IGHG1, CD69, LSP1, HSPA1A, VIM, LTB, CCL5, TRBC2, HLA-DPB1, COTL1 \n       IGLC3, ALOX5AP, TRBC1, IGHG2, GPR183, RGS2, GZMA, TYROBP, NKG7, CD7 \nPC_ 2 \nPositive:  SPARC, IGFBP7, CALD1, COL1A2, COL3A1, COL6A2, COL4A1, IFITM3, MYL9, COL1A1 \n       FN1, TPM2, CAVIN3, THY1, BGN, FSTL1, COX7A1, TIMP1, COL6A1, DCN \n       C1S, TAGLN, C1R, RGS5, COL5A2, LGALS1, SPARCL1, MFGE8, CTGF, COL6A3 \nNegative:  HPGD, GATA3, CD24, S100P, RAB11FIP1, CD3D, SPINK1, PSCA, DHRS2, KRT8 \n       KRT19, KLF5, CD52, UPK2, TRBC2, TMEM97, GDPD3, GDF15, TMPRSS2, VSIG2 \n       UPK1A, SDC4, KRT20, SMIM22, SPTSSB, MGST1, CNGA1, WFDC2, CXADR, UPK3A \nPC_ 3 \nPositive:  CALD1, SPARC, COL3A1, COL6A2, COL1A2, IGFBP7, IL32, COL4A1, COL1A1, RGS5 \n       THY1, MYL9, TPM2, SELENOM, CAVIN3, COL6A1, FSTL1, SOD3, MFGE8, BGN \n       COL5A2, COX7A1, MGP, COL6A3, NDUFA4L2, SPARCL1, PCOLCE, CTGF, C1R, LHFPL6 \nNegative:  TYROBP, FCER1G, LYZ, MS4A6A, CD14, HLA-DRA, FTL, CTSS, CD68, C1QC \n       C1QA, C1QB, MS4A7, FCGR2A, SPI1, OLR1, LST1, MS4A4A, C5AR1, PSAP \n       HLA-DRB5, SERPINA1, APOC1, CTSB, CST3, SAT1, CD163, HLA-DPA1, BCL2A1, HLA-DMA \nPC_ 4 \nPositive:  RAMP2, PCAT19, VWF, CLEC14A, HSPG2, EGFL7, RAMP3, CALCRL, AQP1, ECSCR \n       PCDH17, PODXL, FLT1, CD34, CDH5, VWA1, FAM167B, CLDN5, SLCO2A1, CXorf36 \n       ENG, PECAM1, CYYR1, MMRN2, NOTCH4, SLC9A3R2, INSR, HYAL2, TM4SF1, ESM1 \nNegative:  COL1A2, COL3A1, COL1A1, DCN, COL6A3, TPM2, C1S, PCOLCE, C1R, COL5A2 \n       TAGLN, LUM, SOD3, COL6A1, RARRES2, BGN, ACTA2, MYL9, AEBP1, SERPINF1 \n       COL6A2, CYGB, MXRA8, RGS5, MFGE8, NDUFA4L2, MEG3, PPP1R14A, SDC2, SERPING1 \nPC_ 5 \nPositive:  RNASE1, UPK2, GDPD3, UBE2C, TMEM97, CNGA1, UPK1A, RAB11FIP1, S100A13, UPK3A \n       BHMT, TNFAIP2, STMN1, CD24, TMPRSS2, PLPP5, SDC4, BIRC5, NQO1, SPRR3 \n       EMX2, KRT20, MKI67, ERBB2, CCNB2, CDK1, HMGB2, PCLAF, MYCL, MESP1 \nNegative:  KRT17, FABP4, SERPINB5, DKK1, PLA2G2A, CLU, CLCA4, CRTAC1, LAMB3, S100A2 \n       AQP3, TSPAN1, IGFBP2, IGFBP5, ERRFI1, IRF6, ANXA1, BTBD16, ANXA10, FHL2 \n       SHH, PERP, FABP5, PRAC1, CYP1B1, FOSL1, HSD17B2, SOX15, SFN, GPR87 \n\n\nCode\ngc()\n\n\n             used    (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells   13337837   712.4   19672051  1050.7   19672051  1050.7\nVcells 1682607532 12837.3 5535284451 42230.9 5765849120 43990.0\n\n\nWe can visualize the PCA with DimPlot, coloring by different categorical variables. Here, we see the influence of both the sample (batch) and CD45 positive vs negative (which is correlated to batch but might also contribute to variance).\n\n\nCode\nDimPlot(sc_data, group.by = c(\"sample\", \"CD45\"), reduction = \"pca\") &\n  theme_clean\n\n\n\n\n\n\n\n\n\n\nDimensionality determination\n\nDimensionality of the dataset was then assessed using the JackStraw and ElbowPlot functions.\n\nFrom Seurat documentation, we see that JackStraw is quite computationally intensive:\n\nIn Macosko et al, we implemented a resampling test inspired by the JackStraw procedure. While still available in Seurat (see previous vignette), this is a slow and computationally expensive procedure, and we is no longer routinely used in single cell analysis.\n\nThis is not the most beautiful Elbow plot ever, but the idea is to find the “inflection point” of the plot (I’m estimating at about 10) and go a little bit further into the “stable” area, where adding more dimensions doesn’t add more infromation.\n\n\nCode\nElbowPlot(sc_data, ndims = 30)\n\n\n\n\n\n\n\n\n\nFor methods that require the dimensionality, we’ll set it at 15.\n\n\n\nDoublet detection\nIt’s never a bad idea to add some doublet detection.\nDoublets are UMIs that contained more than one cell and thefore have a mixed profile.\nThis benchmark shows some of the main methods (though new ones may emerge): https://www.sciencedirect.com/science/article/pii/S2405471220304592\nWe’ll use cxds from scdc because it’s fast and reasonably accurate.\nHowever, it uses a SingleCellExperiment standard. Luckily, we can easily convert between SeuratObject and SingleCellExperiment.\n\n\nCode\ncxds_scores &lt;- lapply(SplitObject(sc_data, split.by = \"sample\"), function(samp_sc) {\n  sce &lt;- samp_sc |&gt;\n    as.SingleCellExperiment() |&gt;\n    cxds()\n  return(sce$cxds_score)\n})\ngc()\n\n\n             used    (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells   13355345   713.3   19672051  1050.7   19672051  1050.7\nVcells 1682219409 12834.4 5535284451 42230.9 5765849120 43990.0\n\n\nCode\nnames(cxds_scores) &lt;- NULL\nsc_data$cxds_scores &lt;- do.call(c, cxds_scores)[Cells(sc_data)]"
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#clustering",
    "href": "posts/tutorial_seurat_du/index.html#clustering",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Clustering",
    "text": "Clustering\n\nClusters were calculated […]\n\nBefore clustering, we need to establish a neighborhood graph and compute shared nearest neighbors (SNN). We’ll do this on 15 PCs:\n\n\nCode\nsc_data &lt;- FindNeighbors(sc_data, dims = 1:15)\n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nFrom this, we can use “FindClusters” for Louvain clustering, which uses a rather temperamental “resolution” parameter, very dependent on datasets usually.\nThe largest the “resolution”, the more clusters are obtained.\n\n\nCode\nsc_data &lt;- FindClusters(sc_data, resolution = 0.5, cluster.name = \"unintegrated_clusters\")\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 44699\nNumber of edges: 1534079\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9465\nNumber of communities: 26\nElapsed time: 8 seconds\n\n\nUMAP and t-SNE are dimensionality reductions for visualization. They are very popular and we’ll use them widely. They minimize local distances, often making “neat” looking clusters.\nBe wary of not using the UMAP projection itself as an input for analysis, as they contain lots of data distortions (which is normal of anything that is reducing a space of 3000 features to 2 dimensions)\n\n[…] and data dimensions were reduced using the t-SNE and UMAP methods.\n\n\n\nCode\nsc_data &lt;- RunUMAP(sc_data, dims = 1:15)\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n16:05:11 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n16:05:11 Read 44699 rows and found 15 numeric columns\n\n\n16:05:11 Using Annoy for neighbor search, n_neighbors = 30\n\n\n16:05:11 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n16:05:14 Writing NN index file to temp file /tmp/Rtmp0K4PU7/file109dc176aa34f\n16:05:14 Searching Annoy index using 1 thread, search_k = 3000\n16:05:27 Annoy recall = 100%\n16:05:28 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n16:05:29 Initializing from normalized Laplacian + noise (using RSpectra)\n16:05:31 Commencing optimization for 200 epochs, with 1900728 positive edges\n16:05:45 Optimization finished\n\n\nWe can check the state of our Seurat object:\n\n\nCode\nsc_data\n\n\nAn object of class Seurat \n33538 features across 44699 samples within 1 assay \nActive assay: RNA (33538 features, 2000 variable features)\n 21 layers present: counts.1, counts.2, counts.3, counts.4, counts.5, counts.6, counts.7, counts.8, counts.9, counts.10, data.1, data.2, data.3, data.4, data.5, data.6, data.7, data.8, data.9, data.10, scale.data\n 2 dimensional reductions calculated: pca, umap\n\n\nAnd plot the Seurat clusters… only to find we’re definitely clustering per sample.\n\n\nCode\nDimPlot(sc_data, group.by = c(\"unintegrated_clusters\", \"sample\"), reduction = \"umap\", alpha = 0.3) & \n  theme_clean"
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#integration",
    "href": "posts/tutorial_seurat_du/index.html#integration",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Integration",
    "text": "Integration\nBatch effect is rampant in single-cell RNA-seq and there are lots of integration methods proposed to deal with this. They often return a dimensionality reduction (more precisely, latent space) that minimizes this batch effect.\nThere are 5 methods implemented in Seurat alone. We’ll use Harmony, because it’s fairly fast and effective, but see this benchmark for the most performant methods:\nSee the reference tutorial: https://satijalab.org/seurat/articles/seurat5_integration\n\nBulk cells were merged for the HLA analysis, while CD8 T cells only were merged for the CD8 T cell analysis. CD8 T cells were identified using the FindAllMarkers and the VlnPlot functions.\n\n\n\nCode\nsc_data &lt;- IntegrateLayers(sc_data, \n                           method = HarmonyIntegration,\n                           orig.reduction = \"pca\", \n                           new.reduction = \"harmony\",\n  verbose = FALSE\n)\n\n\nWarning in harmony::HarmonyMatrix(data_mat = Embeddings(object = orig), :\nHarmonyMatrix is deprecated and will be removed in the future from the API in\nthe future\n\n\nWarning: Warning: The parameters do_pca and npcs are deprecated. They will be ignored for this function call and please remove parameters do_pca and npcs and pass to harmony cell_embeddings directly.\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter tau is deprecated. It will be ignored for this function call and please remove parameter tau in future function calls. Advanced users can set value of parameter tau by using parameter .options and function harmony_options().\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter block.size is deprecated. It will be ignored for this function call and please remove parameter block.size in future function calls. Advanced users can set value of parameter block.size by using parameter .options and function harmony_options().\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter max.iter.harmony is replaced with parameter max_iter. It will be ignored for this function call and please use parameter max_iter in future function calls.\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter max.iter.cluster is deprecated. It will be ignored for this function call and please remove parameter max.iter.cluster in future function calls. Advanced users can set value of parameter max.iter.cluster by using parameter .options and function harmony_options().\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter epsilon.cluster is deprecated. It will be ignored for this function call and please remove parameter epsilon.cluster in future function calls. Advanced users can set value of parameter epsilon.cluster by using parameter .options and function harmony_options().\nThis warning is displayed once per session.\n\n\nWarning: Warning: The parameter epsilon.harmony is deprecated. It will be ignored for this function call and please remove parameter epsilon.harmony in future function calls. If users want to control if harmony would stop early or not, use parameter early_stop. Advanced users can set value of parameter epsilon.harmony by using parameter .options and function harmony_options().\nThis warning is displayed once per session.\n\n\nCode\ngc()\n\n\n             used    (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells   13450625   718.4   19672051  1050.7   19672051  1050.7\nVcells 1691093256 12902.1 5535284451 42230.9 5765849120 43990.0\n\n\nWe’ll need re-run clustering algorithm in the Harmony latent space (here, using 30 dimensions)\n\n\nCode\nsc_data &lt;- FindNeighbors(sc_data, reduction = \"harmony\", dims = 1:30)\n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nCode\nsc_data &lt;- FindClusters(sc_data, resolution = 0.5, cluster.name = \"harmony_clusters\")\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 44699\nNumber of edges: 1710955\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9238\nNumber of communities: 18\nElapsed time: 10 seconds\n\n\nWe can also run a UMAP in this latent space:\n\n\nCode\nsc_data &lt;- RunUMAP(sc_data, reduction = \"harmony\", dims = 1:30, reduction.name = \"umap_harmony\")\n\n\n16:07:26 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n16:07:26 Read 44699 rows and found 30 numeric columns\n\n\n16:07:26 Using Annoy for neighbor search, n_neighbors = 30\n\n\n16:07:26 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n16:07:29 Writing NN index file to temp file /tmp/Rtmp0K4PU7/file109dc39bcd86a\n16:07:29 Searching Annoy index using 1 thread, search_k = 3000\n16:07:42 Annoy recall = 100%\n16:07:43 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n16:07:44 Initializing from normalized Laplacian + noise (using RSpectra)\n16:07:46 Commencing optimization for 200 epochs, with 2061946 positive edges\n16:08:01 Optimization finished\n\n\n\n\nCode\nDimPlot(sc_data, \n        group.by = c(\"unintegrated_clusters\", \"harmony_clusters\", \"sample\"), \n        reduction = \"umap_harmony\",\n        alpha = 0.2,\n        ncol = 2) & \n  theme_clean\n\n\n\n\n\n\n\n\n\n\nCheck biases\nWe can check back on our features that could be markers of bias in a cluster, and check back in with our doublet scores:\n\n\nCode\nsc_data$cxds_scores[1:5]\n\n\nAAACCTGAGGCCCTCA-1_1 AAACCTGAGTTCGCGC-1_1 AAACCTGCACTGTTAG-1_1 \n           266320.09             29805.91            219085.93 \nAAACCTGCAGACGCTC-1_1 AAACCTGGTACAGCAG-1_1 \n           100458.58            193619.85 \n\n\n\n\nCode\nRidgePlot(sc_data, \n        features = c(\"nCount_RNA\", \"nFeature_RNA\", \n                     \"percent.mt\",\"cxds_scores\"), \n        ncol = 2) &\n  guides(fill = \"none\") &\n  theme_clean \n\n\nPicking joint bandwidth of 569\n\n\nPicking joint bandwidth of 123\n\n\nPicking joint bandwidth of 0.469\n\n\nPicking joint bandwidth of 6840\n\n\n\n\n\n\n\n\n\nWe can see, for example, that cluster 17 seems to be enriched in doublets.\nTo compare the co-occurence of two categorical variables, we can do a heatmap:\n\n\nCode\ntable(sc_data$harmony_clusters, sc_data$sample) |&gt;\n  pheatmap(scale = \"row\")\n\n\n\n\n\n\n\n\n\nFrom this, we can exclude cluster 17:\n\n\nCode\nsc_data &lt;- subset(sc_data, subset = harmony_clusters != 17)"
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#annotation",
    "href": "posts/tutorial_seurat_du/index.html#annotation",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Annotation",
    "text": "Annotation\n\nDifferential Expression\nDifferential expression analysis will by default run on the “identity” feature, which we make sure to set as “harmony_clusters” at this point:\n\n\nCode\nIdents(sc_data) &lt;- sc_data$harmony_clusters\nIdents(sc_data)[1:5]\n\n\nAAACCTGAGGCCCTCA-1_1 AAACCTGAGTTCGCGC-1_1 AAACCTGCACTGTTAG-1_1 \n                   2                    6                    1 \nAAACCTGCAGACGCTC-1_1 AAACCTGGTACAGCAG-1_1 \n                   3                    1 \nLevels: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\n\nFor differential analysis to use all layers at the same time, we need to join them before finding markers (each clusters vs all others):\n\n\nCode\nsc_data &lt;- JoinLayers(sc_data)\nmarkers &lt;- FindAllMarkers(sc_data)\n\n\nCalculating cluster 0\n\n\nCalculating cluster 1\n\n\nCalculating cluster 2\n\n\nCalculating cluster 3\n\n\nCalculating cluster 4\n\n\nCalculating cluster 5\n\n\nCalculating cluster 6\n\n\nCalculating cluster 7\n\n\nCalculating cluster 8\n\n\nCalculating cluster 9\n\n\nCalculating cluster 10\n\n\nCalculating cluster 11\n\n\nCalculating cluster 12\n\n\nCalculating cluster 13\n\n\nCalculating cluster 14\n\n\nCalculating cluster 15\n\n\nCalculating cluster 16\n\n\nFor annotation, we can now use this table:\n\n\nCode\nmarkers |&gt; head()\n\n\n     p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene\nIL7R     0   2.929902 0.634 0.158         0       0 IL7R\nCD3D     0   1.512433 0.750 0.281         0       0 CD3D\nIL32     0   1.225477 0.865 0.404         0       0 IL32\nTRAC     0   1.525893 0.722 0.273         0       0 TRAC\nLTB      0   2.055308 0.713 0.273         0       0  LTB\nCD2      0   1.805078 0.660 0.230         0       0  CD2\n\n\nAnd visualize either top markers or any chosen features in many different ways:\n\n\nCode\ntop_markers &lt;- markers |&gt;\n    group_by(cluster) |&gt;\n    dplyr::filter(avg_log2FC &gt; 1) |&gt;\n    arrange(p_val_adj) |&gt;\n    slice_head(n = 5) |&gt;\n    ungroup()\ntop5 &lt;- unique(top_markers$gene)\n\n\n\nHeatmap\nThe heatmap takes a while to run, but provides a comprehensive view of a marker expression over the cells:\n\n\nCode\nDoHeatmap(subset(sc_data, downsample = 1e4), features = top5, raster = TRUE) +\n  scale_fill_viridis_c()\n\n\n\n\nDot plot\nThe dotplot summarizes the information into the heatmap and gives the same importance to all clusters, independent of size:\n\n\nCode\nDotPlot(sc_data, features = top5, cluster.idents = TRUE) + theme_clean\n\n\n\n\n\n\n\n\n\n\n\nFeaturePlot\nFeaturePlot is the same as DimPlot, but using one or many continuous values instead:\n\n\nCode\nFeaturePlot(sc_data, reduction = \"umap_harmony\",\n            features = c(\"CD3D\", \"MS4A1\",\n                         \"CD14\", \"PECAM1\",\n                         \"KRT20\", \"KRT5\")) &\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\n\nReference-based\nThere are an infinity of methods for cell type annotation. I’ve found that using a good reference is more important than the method for annotation.\nWe’ll show reference-based annotation using SingleR, mostly because it’s easy to use but also well performing.\n\n“Built-in” references\nEvery automatic annotation method uses a reference. celldex provides an easy way to access some annotation sources, notably the Human Primary Cell Atlas, which we will use in this example.\n\n\nCode\nlibrary(celldex)\nsurveyReferences() |&gt;  as_tibble()\n\n\n# A tibble: 7 × 10\n  name         version path  title description taxonomy_id genome samples labels\n  &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;list&gt;      &lt;list&gt;   &lt;int&gt; &lt;list&gt;\n1 dice         2024-0… &lt;NA&gt;  Huma… Human bulk… &lt;list [1]&gt;  &lt;list&gt;    1561 &lt;list&gt;\n2 blueprint_e… 2024-0… &lt;NA&gt;  Huma… Human bulk… &lt;list [1]&gt;  &lt;list&gt;     259 &lt;list&gt;\n3 immgen       2024-0… &lt;NA&gt;  Mous… Mouse micr… &lt;list [1]&gt;  &lt;list&gt;     830 &lt;list&gt;\n4 mouse_rnaseq 2024-0… &lt;NA&gt;  Bulk… Bulk RNA-s… &lt;list [1]&gt;  &lt;list&gt;     358 &lt;list&gt;\n5 hpca         2024-0… &lt;NA&gt;  Micr… Microarray… &lt;list [1]&gt;  &lt;list&gt;     713 &lt;list&gt;\n6 novershtern… 2024-0… &lt;NA&gt;  Bulk… Bulk micro… &lt;list [1]&gt;  &lt;list&gt;     211 &lt;list&gt;\n7 monaco_immu… 2024-0… &lt;NA&gt;  Huma… Human bulk… &lt;list [1]&gt;  &lt;list&gt;     114 &lt;list&gt;\n# ℹ 1 more variable: sources &lt;list&gt;\n\n\n\n\nCode\nhpca_se &lt;- celldex::HumanPrimaryCellAtlasData()\nhpca_se\n\n\nclass: SummarizedExperiment \ndim: 19363 713 \nmetadata(0):\nassays(1): logcounts\nrownames(19363): A1BG A1BG-AS1 ... ZZEF1 ZZZ3\nrowData names(0):\ncolnames(713): GSM112490 GSM112491 ... GSM92233 GSM92234\ncolData names(3): label.main label.fine label.ont\n\n\nIt’s given as a SummarizedExperiment of purified bulk tumors.=, annotated as follows:\n\n\nCode\nunique(hpca_se$label.main)\n\n\n [1] \"DC\"                   \"Smooth_muscle_cells\"  \"Epithelial_cells\"    \n [4] \"B_cell\"               \"Neutrophils\"          \"T_cells\"             \n [7] \"Monocyte\"             \"Erythroblast\"         \"BM & Prog.\"          \n[10] \"Endothelial_cells\"    \"Gametocytes\"          \"Neurons\"             \n[13] \"Keratinocytes\"        \"HSC_-G-CSF\"           \"Macrophage\"          \n[16] \"NK_cell\"              \"Embryonic_stem_cells\" \"Tissue_stem_cells\"   \n[19] \"Chondrocytes\"         \"Osteoblasts\"          \"BM\"                  \n[22] \"Platelets\"            \"Fibroblasts\"          \"iPS_cells\"           \n[25] \"Hepatocytes\"          \"MSC\"                  \"Neuroepithelial_cell\"\n[28] \"Astrocyte\"            \"HSC_CD34+\"            \"CMP\"                 \n[31] \"GMP\"                  \"MEP\"                  \"Myelocyte\"           \n[34] \"Pre-B_cell_CD34-\"     \"Pro-B_cell_CD34+\"     \"Pro-Myelocyte\"       \n\n\nThere’s also a finer annotation, which we won’t use:\n\n\nCode\nunique(hpca_se$label.fine) |&gt; head(n = 20)\n\n\n [1] \"DC:monocyte-derived:immature\"        \"DC:monocyte-derived:Galectin-1\"     \n [3] \"DC:monocyte-derived:LPS\"             \"DC:monocyte-derived\"                \n [5] \"Smooth_muscle_cells:bronchial:vit_D\" \"Smooth_muscle_cells:bronchial\"      \n [7] \"Epithelial_cells:bronchial\"          \"B_cell\"                             \n [9] \"Neutrophil\"                          \"T_cell:CD8+_Central_memory\"         \n[11] \"T_cell:CD8+\"                         \"T_cell:CD4+\"                        \n[13] \"T_cell:CD8+_effector_memory_RA\"      \"T_cell:CD8+_effector_memory\"        \n[15] \"T_cell:CD8+_naive\"                   \"Monocyte\"                           \n[17] \"Erythroblast\"                        \"BM\"                                 \n[19] \"DC:monocyte-derived:rosiglitazone\"   \"DC:monocyte-derived:AM580\"          \n\n\nSingleR is really simple to use, we just need to provide an expression matrix and reference as SummarizedExperiment:\n\n\nCode\nlibrary(SingleR)\npred_hpca &lt;- SingleR(test = GetAssayData(sc_data), ref = hpca_se, assay.type.test=1,\n    labels = hpca_se$label.main)\npred_hpca\n\n\nDataFrame with 44535 rows and 4 columns\n                                                scores              labels\n                                              &lt;matrix&gt;         &lt;character&gt;\nAAACCTGAGGCCCTCA-1_1   0.2029037:0.213122:0.201966:...    Epithelial_cells\nAAACCTGAGTTCGCGC-1_1   0.0681688:0.198615:0.175877:...              B_cell\nAAACCTGCACTGTTAG-1_1   0.0876658:0.201213:0.204570:...             T_cells\nAAACCTGCAGACGCTC-1_1   0.1877214:0.195236:0.193748:...    Epithelial_cells\nAAACCTGGTACAGCAG-1_1   0.0911602:0.192878:0.188423:...             T_cells\n...                                                ...                 ...\nTTTGTCAGTAAGTAGT-1_10 0.1291041:0.126240:0.0979679:...   Endothelial_cells\nTTTGTCAGTCCTCCAT-1_10 0.2087580:0.136874:0.1276952:... Smooth_muscle_cells\nTTTGTCAGTCTAGTCA-1_10 0.1394180:0.249968:0.2645048:...            Monocyte\nTTTGTCAGTGCTGTAT-1_10 0.2323622:0.210428:0.1944528:...   Endothelial_cells\nTTTGTCATCTAGCACA-1_10 0.0968535:0.202014:0.1887533:...             NK_cell\n                      delta.next       pruned.labels\n                       &lt;numeric&gt;         &lt;character&gt;\nAAACCTGAGGCCCTCA-1_1   0.0539724    Epithelial_cells\nAAACCTGAGTTCGCGC-1_1   0.0693563              B_cell\nAAACCTGCACTGTTAG-1_1   0.1751957             T_cells\nAAACCTGCAGACGCTC-1_1   0.5717106    Epithelial_cells\nAAACCTGGTACAGCAG-1_1   0.0322466             T_cells\n...                          ...                 ...\nTTTGTCAGTAAGTAGT-1_10 0.05911158   Endothelial_cells\nTTTGTCAGTCCTCCAT-1_10 0.00671502 Smooth_muscle_cells\nTTTGTCAGTCTAGTCA-1_10 0.02419472            Monocyte\nTTTGTCAGTGCTGTAT-1_10 0.06293215   Endothelial_cells\nTTTGTCATCTAGCACA-1_10 0.09986082             NK_cell\n\n\nOnce we have the predictions, I add it to the Seurat object:\n\n\nCode\nsc_data@tools[[\"SingleR\"]] &lt;- pred_hpca |&gt; as.data.frame()\nsc_data$singleR_pred &lt;- pred_hpca$pruned.labels\n\n\n\nHarmonizing automatic predictions\nWe can check the prediction results and “harmonize” them by cluster, i.e. take the cluster-level mode of the annotation:\n\n\nCode\nharmony_singler &lt;- table(sc_data$singleR_pred, factor(sc_data$harmony_clusters))\npheatmap::pheatmap(harmony_singler, scale = \"column\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nharmony_map1 &lt;- apply(harmony_singler, 2, function(x) names(which.max(x)))\nharmony_map1 &lt;- structure(names(harmony_map1), names = harmony_map1)\nharmony_map1\n\n\n          T_cells           T_cells  Epithelial_cells  Epithelial_cells \n              \"0\"               \"1\"               \"2\"               \"3\" \n         Monocyte        Macrophage            B_cell Tissue_stem_cells \n              \"4\"               \"5\"               \"6\"               \"7\" \n          T_cells            B_cell  Epithelial_cells  Epithelial_cells \n              \"8\"               \"9\"              \"10\"              \"11\" \nEndothelial_cells          Monocyte               CMP  Pre-B_cell_CD34- \n             \"12\"              \"13\"              \"14\"              \"15\" \n               DC \n             \"16\" \n\n\n\n\nCode\nsc_data$singleR_clean &lt;- fct_recode(sc_data$harmony_clusters, !!! harmony_map1)\n\n\nIf we plot, we can see the difference between the “pred” and “clean”:\n\n\nCode\nDimPlot(sc_data, \n        group.by = c(\"harmony_clusters\", \"singleR_pred\", \n                     \"singleR_clean\", \"sample\"), \n        reduction = \"umap_harmony\",\n        ncol = 2,\n        alpha = 0.2) & \n  theme_clean &\n  scale_color_igv()\n\n\nWarning: Removed 67 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\nSingle-cell\nMost methods will work best with a relevant single-cell reference.\nHere is a not-so-recent but independent benchmark: https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1795-z\nIt can be interesting to try to use this tutorial to annotate a query dataset based on a reference atlas: https://satijalab.org/seurat/articles/integration_mapping\nNote: always take automatic annotations with a grain of salt. They are a good departure point, but the assignment to a cell type needs to be checked manually. A good way is to go back to the differentially expressed markers using your group annotations."
  },
  {
    "objectID": "posts/tutorial_seurat_du/index.html#extras",
    "href": "posts/tutorial_seurat_du/index.html#extras",
    "title": "R and Seurat to analyse single cell RNA-seq",
    "section": "Extras",
    "text": "Extras\n\nSub-cluster\nIn their manuscript, Salomé et al selected the T cells and subclustered them. This is a common strategy when there is a main population of interest of which we would like to characterize functional states or subpopulations. It can also be interesting to provide more detailed annotations, since the space of analysis changes.\nTo use subclusters, just subset the object to the annotated cells and re-run the pipeline to find new relevant subgroups.\n\n\nTrajectory analysis\nTrajectory analysis is used to reconstruct and visualize the dynamic processes of cellular development, differentiation, and state transitions. It infers the order of cells in a particular trajectory, allows us to calculate continuous “pseudotimes”.\nIt can be used to map out potential lineage relationships, identify intermediate cell states, and elucidate the pathways underlying tissue development, immune responses, or disease progression, for example.\nIn Figure 4, Salomé et al used this type of analysis to show a subset of differentiated PD-1+ TRM CD8+ T Cells that retain independent function.\n\nA not so new but very comprehensive benchmark of trajectory inference by Saelens et al (2019) is a great jumping point: https://www.nature.com/articles/s41587-019-0071-9\nAccompanied by the superb dynverse wrappers, which provide all methods in the benchmark, as well as guidance on what to choose: https://dynverse.org/\n\n\nCell cycle\nThere are many methods to infer cell cycle stage and score cell cycle in Seurat, but it also has a built in one that works quite decently:\n\n\nCode\nsc_data &lt;- CellCycleScoring(sc_data, \n                 s.features = cc.genes.updated.2019$s.genes, \n                 g2m.features = cc.genes.updated.2019$g2m.genes)\n\n\n\n\nCode\nFeaturePlot(sc_data, \n        features = c(\"S.Score\", \"G2M.Score\"),\n        reduction = \"umap_harmony\",\n        ncol = 2,\n        alpha = 0.2) & \n  theme_clean\n\n\n\n\n\n\n\n\n\nWe can see very little cycling except in one “epithelial” (tumor) area we previously annotated.\n\n\nRNA velocity\nRNA velocity is a computation method that attempts to predict the future transcriptional state of individual cells. It distinguishes between unspliced (pre-mRNA) and spliced (mature mRNA) transcripts within each cell, and therefore necessitates a special input in which these reads have been separated. This differentiation allows the estimation of the rate at which genes are being transcribed and processed, providing insights into the “direction” and “speed” of cellular state changes.\nThe primary goal of RNA velocity analysis is to elucidate the trajectories of cellular differentiation, activation, and other dynamic processes, thereby offering a deeper understanding of cellular development and lineage relationships. By forecasting how cells are likely to evolve, it can help in identifying transient cell states, and uncovering mechanisms underlying tissue development, regeneration, and disease progression.\nIt can be used together with traditional trajectory analysis.\nIn Salomé et al (2022), this analysis is used in Figure 5 to further characterize the axis of differentiation/exhaustion of CD8+ TRM cells, shown below:\n\nMost RNA velocity tools work in Python, the two most well-known being velocyto and scVelo. Both have tutorials showing how to use reticulate to run their workflows in R.\n\n\nPathway enrichment\nPathway enrichment aims to identify biological pathways, processes, or functional categories that are significantly overrepresented within a set of genes of interest, such as those differentially expressed between distinct cell populations or states.\nThis analysis typically involves mapping the selected genes to curated pathway databases like Gene Ontology, KEGG, or Reactome and applying statistical methods to assess the significance of their enrichment.\nThere are many methods to do this, but a easy to use is decoupleR, in which AUCell is implemented, which is a well-performing scoring method: https://www.bioconductor.org/packages/release/bioc/vignettes/decoupleR/inst/doc/decoupleR.html\n\n\nGene regulatory network\nGene regulatory network (GRN) analysis seeks to identify key transcription factors, regulatory motifs, and signaling pathways that drive cell states, differentiation, and responses to environmental stimuli. The ultimate goal of GRN analysis is to map out the regulatory architecture that underpins cellular heterogeneity, enabling us to pinpoint master regulators and understand the molecular mechanisms underlying various biological processes and disease states.\nFrom an algorithmic point of view, this involves inferring relationships such as gene co-expression, regulatory influences, and causal interactions.\nSCENIC is the most popular method to do this, with the Python implementation being much more performant (https://github.com/aertslab/pySCENIC). The protocol is probably the best way to run this type of analysis currently: https://github.com/aertslab/SCENICprotocol\n\n\nCNV analysis\nCopy Number Variation (CNV) analysis is a computational approach used to infer genomic copy number alterations from transcriptomic data. It leverages the variability in gene expression levels across the genome to detect gains or losses of genomic regions.\nThis method is particularly valuable in studies of cancer and other genetic disorders, where CNVs play a crucial role in disease progression and heterogeneity.\nThe most well-known tool used for this analysis is inferCNV, which can be extremely slow and doesn’t perform very well with cells with low-read count. This is why we implemented fastCNV, available to install for R on Github: https://github.com/must-bioinfo/fastCNVdata\n\n\nLigand-receptor analysis\nLigand-receptor analysis is a computational strategy to infer cell-cell communication by identifying interactions between signaling molecules (ligands) and their corresponding receptors expressed on different cell types or states.\nThis analysis involves systematically pairing ligands expressed by one or more cell populations with receptors expressed by neighboring or interacting cells, thereby predicting potential signaling pathways that facilitate intercellular communication.\nWell known tools are CellPhoneDB and CellChat, but LIANA+ provides wrappers and an all-in-one framework for this kind of analysis: https://liana-py.readthedocs.io/en/latest/\nNotably, this analysis can be much more powerful in spatially-resolved data.\n\n\nObject conversion\nFormat conversion is often necessary when working with single-cell RNA-seq to use tools available for different objects.\nThis can be easy between SingleCellExperiment and SeuratObject, as we used it in this tutorial with as.SingleCellExperiment and as.Seurat.\nHowever, these functions sometimes don’t work and the Seurat solution for h5 objects, SeuratDisk, even fails its own tutorial.\nsceasy (https://github.com/cellgeni/sceasy) was made to resolve these conversion problems. Note that it requires reticulate (to make Python work in R) to be installed."
  }
]